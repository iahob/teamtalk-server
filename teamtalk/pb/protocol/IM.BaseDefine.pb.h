// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: IM.BaseDefine.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_IM_2eBaseDefine_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_IM_2eBaseDefine_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3018000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3018001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_IM_2eBaseDefine_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_IM_2eBaseDefine_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[15]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_IM_2eBaseDefine_2eproto;
namespace IM {
namespace BaseDefine {
class ContactSessionInfo;
struct ContactSessionInfoDefaultTypeInternal;
extern ContactSessionInfoDefaultTypeInternal _ContactSessionInfo_default_instance_;
class DepartInfo;
struct DepartInfoDefaultTypeInternal;
extern DepartInfoDefaultTypeInternal _DepartInfo_default_instance_;
class GroupInfo;
struct GroupInfoDefaultTypeInternal;
extern GroupInfoDefaultTypeInternal _GroupInfo_default_instance_;
class GroupVersionInfo;
struct GroupVersionInfoDefaultTypeInternal;
extern GroupVersionInfoDefaultTypeInternal _GroupVersionInfo_default_instance_;
class IpAddr;
struct IpAddrDefaultTypeInternal;
extern IpAddrDefaultTypeInternal _IpAddr_default_instance_;
class MsgInfo;
struct MsgInfoDefaultTypeInternal;
extern MsgInfoDefaultTypeInternal _MsgInfo_default_instance_;
class OfflineFileInfo;
struct OfflineFileInfoDefaultTypeInternal;
extern OfflineFileInfoDefaultTypeInternal _OfflineFileInfo_default_instance_;
class PushResult;
struct PushResultDefaultTypeInternal;
extern PushResultDefaultTypeInternal _PushResult_default_instance_;
class PushShieldStatus;
struct PushShieldStatusDefaultTypeInternal;
extern PushShieldStatusDefaultTypeInternal _PushShieldStatus_default_instance_;
class ServerUserStat;
struct ServerUserStatDefaultTypeInternal;
extern ServerUserStatDefaultTypeInternal _ServerUserStat_default_instance_;
class ShieldStatus;
struct ShieldStatusDefaultTypeInternal;
extern ShieldStatusDefaultTypeInternal _ShieldStatus_default_instance_;
class UnreadInfo;
struct UnreadInfoDefaultTypeInternal;
extern UnreadInfoDefaultTypeInternal _UnreadInfo_default_instance_;
class UserInfo;
struct UserInfoDefaultTypeInternal;
extern UserInfoDefaultTypeInternal _UserInfo_default_instance_;
class UserStat;
struct UserStatDefaultTypeInternal;
extern UserStatDefaultTypeInternal _UserStat_default_instance_;
class UserTokenInfo;
struct UserTokenInfoDefaultTypeInternal;
extern UserTokenInfoDefaultTypeInternal _UserTokenInfo_default_instance_;
}  // namespace BaseDefine
}  // namespace IM
PROTOBUF_NAMESPACE_OPEN
template<> ::IM::BaseDefine::ContactSessionInfo* Arena::CreateMaybeMessage<::IM::BaseDefine::ContactSessionInfo>(Arena*);
template<> ::IM::BaseDefine::DepartInfo* Arena::CreateMaybeMessage<::IM::BaseDefine::DepartInfo>(Arena*);
template<> ::IM::BaseDefine::GroupInfo* Arena::CreateMaybeMessage<::IM::BaseDefine::GroupInfo>(Arena*);
template<> ::IM::BaseDefine::GroupVersionInfo* Arena::CreateMaybeMessage<::IM::BaseDefine::GroupVersionInfo>(Arena*);
template<> ::IM::BaseDefine::IpAddr* Arena::CreateMaybeMessage<::IM::BaseDefine::IpAddr>(Arena*);
template<> ::IM::BaseDefine::MsgInfo* Arena::CreateMaybeMessage<::IM::BaseDefine::MsgInfo>(Arena*);
template<> ::IM::BaseDefine::OfflineFileInfo* Arena::CreateMaybeMessage<::IM::BaseDefine::OfflineFileInfo>(Arena*);
template<> ::IM::BaseDefine::PushResult* Arena::CreateMaybeMessage<::IM::BaseDefine::PushResult>(Arena*);
template<> ::IM::BaseDefine::PushShieldStatus* Arena::CreateMaybeMessage<::IM::BaseDefine::PushShieldStatus>(Arena*);
template<> ::IM::BaseDefine::ServerUserStat* Arena::CreateMaybeMessage<::IM::BaseDefine::ServerUserStat>(Arena*);
template<> ::IM::BaseDefine::ShieldStatus* Arena::CreateMaybeMessage<::IM::BaseDefine::ShieldStatus>(Arena*);
template<> ::IM::BaseDefine::UnreadInfo* Arena::CreateMaybeMessage<::IM::BaseDefine::UnreadInfo>(Arena*);
template<> ::IM::BaseDefine::UserInfo* Arena::CreateMaybeMessage<::IM::BaseDefine::UserInfo>(Arena*);
template<> ::IM::BaseDefine::UserStat* Arena::CreateMaybeMessage<::IM::BaseDefine::UserStat>(Arena*);
template<> ::IM::BaseDefine::UserTokenInfo* Arena::CreateMaybeMessage<::IM::BaseDefine::UserTokenInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace IM {
namespace BaseDefine {

enum ServiceID : int {
  SID_UNKNOWN = 0,
  SID_LOGIN = 1,
  SID_BUDDY_LIST = 2,
  SID_MSG = 3,
  SID_GROUP = 4,
  SID_FILE = 5,
  SID_SWITCH_SERVICE = 6,
  SID_OTHER = 7,
  SID_INTERNAL = 8,
  ServiceID_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ServiceID_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ServiceID_IsValid(int value);
constexpr ServiceID ServiceID_MIN = SID_UNKNOWN;
constexpr ServiceID ServiceID_MAX = SID_INTERNAL;
constexpr int ServiceID_ARRAYSIZE = ServiceID_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ServiceID_descriptor();
template<typename T>
inline const std::string& ServiceID_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ServiceID>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ServiceID_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ServiceID_descriptor(), enum_t_value);
}
inline bool ServiceID_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ServiceID* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ServiceID>(
    ServiceID_descriptor(), name, value);
}
enum LoginCmdID : int {
  CID_LOGIN_UNKNOWN = 0,
  CID_LOGIN_REQ_MSGSERVER = 257,
  CID_LOGIN_RES_MSGSERVER = 258,
  CID_LOGIN_REQ_USERLOGIN = 259,
  CID_LOGIN_RES_USERLOGIN = 260,
  CID_LOGIN_REQ_LOGINOUT = 261,
  CID_LOGIN_RES_LOGINOUT = 262,
  CID_LOGIN_KICK_USER = 263,
  CID_LOGIN_REQ_DEVICETOKEN = 264,
  CID_LOGIN_RES_DEVICETOKEN = 265,
  CID_LOGIN_REQ_KICKPCCLIENT = 266,
  CID_LOGIN_RES_KICKPCCLIENT = 267,
  CID_LOGIN_REQ_PUSH_SHIELD = 268,
  CID_LOGIN_RES_PUSH_SHIELD = 269,
  CID_LOGIN_REQ_QUERY_PUSH_SHIELD = 270,
  CID_LOGIN_RES_QUERY_PUSH_SHIELD = 271,
  LoginCmdID_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  LoginCmdID_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool LoginCmdID_IsValid(int value);
constexpr LoginCmdID LoginCmdID_MIN = CID_LOGIN_UNKNOWN;
constexpr LoginCmdID LoginCmdID_MAX = CID_LOGIN_RES_QUERY_PUSH_SHIELD;
constexpr int LoginCmdID_ARRAYSIZE = LoginCmdID_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LoginCmdID_descriptor();
template<typename T>
inline const std::string& LoginCmdID_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LoginCmdID>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LoginCmdID_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LoginCmdID_descriptor(), enum_t_value);
}
inline bool LoginCmdID_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LoginCmdID* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LoginCmdID>(
    LoginCmdID_descriptor(), name, value);
}
enum BuddyListCmdID : int {
  CID_BUDDY_LIST_UNKNOWN = 0,
  CID_BUDDY_LIST_RECENT_CONTACT_SESSION_REQUEST = 513,
  CID_BUDDY_LIST_RECENT_CONTACT_SESSION_RESPONSE = 514,
  CID_BUDDY_LIST_STATUS_NOTIFY = 515,
  CID_BUDDY_LIST_USER_INFO_REQUEST = 516,
  CID_BUDDY_LIST_USER_INFO_RESPONSE = 517,
  CID_BUDDY_LIST_REMOVE_SESSION_REQ = 518,
  CID_BUDDY_LIST_REMOVE_SESSION_RES = 519,
  CID_BUDDY_LIST_ALL_USER_REQUEST = 520,
  CID_BUDDY_LIST_ALL_USER_RESPONSE = 521,
  CID_BUDDY_LIST_USERS_STATUS_REQUEST = 522,
  CID_BUDDY_LIST_USERS_STATUS_RESPONSE = 523,
  CID_BUDDY_LIST_CHANGE_AVATAR_REQUEST = 524,
  CID_BUDDY_LIST_CHANGE_AVATAR_RESPONSE = 525,
  CID_BUDDY_LIST_PC_LOGIN_STATUS_NOTIFY = 526,
  CID_BUDDY_LIST_REMOVE_SESSION_NOTIFY = 527,
  CID_BUDDY_LIST_DEPARTMENT_REQUEST = 528,
  CID_BUDDY_LIST_DEPARTMENT_RESPONSE = 529,
  CID_BUDDY_LIST_AVATAR_CHANGED_NOTIFY = 530,
  CID_BUDDY_LIST_CHANGE_SIGN_INFO_REQUEST = 531,
  CID_BUDDY_LIST_CHANGE_SIGN_INFO_RESPONSE = 532,
  CID_BUDDY_LIST_SIGN_INFO_CHANGED_NOTIFY = 533,
  BuddyListCmdID_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  BuddyListCmdID_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool BuddyListCmdID_IsValid(int value);
constexpr BuddyListCmdID BuddyListCmdID_MIN = CID_BUDDY_LIST_UNKNOWN;
constexpr BuddyListCmdID BuddyListCmdID_MAX = CID_BUDDY_LIST_SIGN_INFO_CHANGED_NOTIFY;
constexpr int BuddyListCmdID_ARRAYSIZE = BuddyListCmdID_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BuddyListCmdID_descriptor();
template<typename T>
inline const std::string& BuddyListCmdID_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BuddyListCmdID>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BuddyListCmdID_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BuddyListCmdID_descriptor(), enum_t_value);
}
inline bool BuddyListCmdID_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BuddyListCmdID* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BuddyListCmdID>(
    BuddyListCmdID_descriptor(), name, value);
}
enum MessageCmdID : int {
  CID_MSG_UNKNOWN = 0,
  CID_MSG_DATA = 769,
  CID_MSG_DATA_ACK = 770,
  CID_MSG_READ_ACK = 771,
  CID_MSG_READ_NOTIFY = 772,
  CID_MSG_TIME_REQUEST = 773,
  CID_MSG_TIME_RESPONSE = 774,
  CID_MSG_UNREAD_CNT_REQUEST = 775,
  CID_MSG_UNREAD_CNT_RESPONSE = 776,
  CID_MSG_LIST_REQUEST = 777,
  CID_MSG_LIST_RESPONSE = 778,
  CID_MSG_GET_LATEST_MSG_ID_REQ = 779,
  CID_MSG_GET_LATEST_MSG_ID_RSP = 780,
  CID_MSG_GET_BY_MSG_ID_REQ = 781,
  CID_MSG_GET_BY_MSG_ID_RES = 782,
  MessageCmdID_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  MessageCmdID_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool MessageCmdID_IsValid(int value);
constexpr MessageCmdID MessageCmdID_MIN = CID_MSG_UNKNOWN;
constexpr MessageCmdID MessageCmdID_MAX = CID_MSG_GET_BY_MSG_ID_RES;
constexpr int MessageCmdID_ARRAYSIZE = MessageCmdID_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MessageCmdID_descriptor();
template<typename T>
inline const std::string& MessageCmdID_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MessageCmdID>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MessageCmdID_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MessageCmdID_descriptor(), enum_t_value);
}
inline bool MessageCmdID_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MessageCmdID* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MessageCmdID>(
    MessageCmdID_descriptor(), name, value);
}
enum GroupCmdID : int {
  CID_GROUP_UNKNOWN = 0,
  CID_GROUP_NORMAL_LIST_REQUEST = 1025,
  CID_GROUP_NORMAL_LIST_RESPONSE = 1026,
  CID_GROUP_INFO_REQUEST = 1027,
  CID_GROUP_INFO_RESPONSE = 1028,
  CID_GROUP_CREATE_REQUEST = 1029,
  CID_GROUP_CREATE_RESPONSE = 1030,
  CID_GROUP_CHANGE_MEMBER_REQUEST = 1031,
  CID_GROUP_CHANGE_MEMBER_RESPONSE = 1032,
  CID_GROUP_SHIELD_GROUP_REQUEST = 1033,
  CID_GROUP_SHIELD_GROUP_RESPONSE = 1034,
  CID_GROUP_CHANGE_MEMBER_NOTIFY = 1035,
  GroupCmdID_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  GroupCmdID_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool GroupCmdID_IsValid(int value);
constexpr GroupCmdID GroupCmdID_MIN = CID_GROUP_UNKNOWN;
constexpr GroupCmdID GroupCmdID_MAX = CID_GROUP_CHANGE_MEMBER_NOTIFY;
constexpr int GroupCmdID_ARRAYSIZE = GroupCmdID_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GroupCmdID_descriptor();
template<typename T>
inline const std::string& GroupCmdID_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GroupCmdID>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GroupCmdID_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GroupCmdID_descriptor(), enum_t_value);
}
inline bool GroupCmdID_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GroupCmdID* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GroupCmdID>(
    GroupCmdID_descriptor(), name, value);
}
enum FileCmdID : int {
  CID_FILE_UNKNOWN = 0,
  CID_FILE_LOGIN_REQ = 1281,
  CID_FILE_LOGIN_RES = 1282,
  CID_FILE_STATE = 1283,
  CID_FILE_PULL_DATA_REQ = 1284,
  CID_FILE_PULL_DATA_RSP = 1285,
  CID_FILE_REQUEST = 1286,
  CID_FILE_RESPONSE = 1287,
  CID_FILE_NOTIFY = 1288,
  CID_FILE_HAS_OFFLINE_REQ = 1289,
  CID_FILE_HAS_OFFLINE_RES = 1290,
  CID_FILE_ADD_OFFLINE_REQ = 1291,
  CID_FILE_DEL_OFFLINE_REQ = 1292,
  FileCmdID_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  FileCmdID_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool FileCmdID_IsValid(int value);
constexpr FileCmdID FileCmdID_MIN = CID_FILE_UNKNOWN;
constexpr FileCmdID FileCmdID_MAX = CID_FILE_DEL_OFFLINE_REQ;
constexpr int FileCmdID_ARRAYSIZE = FileCmdID_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FileCmdID_descriptor();
template<typename T>
inline const std::string& FileCmdID_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FileCmdID>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FileCmdID_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FileCmdID_descriptor(), enum_t_value);
}
inline bool FileCmdID_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FileCmdID* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FileCmdID>(
    FileCmdID_descriptor(), name, value);
}
enum SwitchServiceCmdID : int {
  CID_SWITCH_UNKNOWN = 0,
  CID_SWITCH_P2P_CMD = 1537,
  SwitchServiceCmdID_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  SwitchServiceCmdID_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool SwitchServiceCmdID_IsValid(int value);
constexpr SwitchServiceCmdID SwitchServiceCmdID_MIN = CID_SWITCH_UNKNOWN;
constexpr SwitchServiceCmdID SwitchServiceCmdID_MAX = CID_SWITCH_P2P_CMD;
constexpr int SwitchServiceCmdID_ARRAYSIZE = SwitchServiceCmdID_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SwitchServiceCmdID_descriptor();
template<typename T>
inline const std::string& SwitchServiceCmdID_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SwitchServiceCmdID>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SwitchServiceCmdID_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SwitchServiceCmdID_descriptor(), enum_t_value);
}
inline bool SwitchServiceCmdID_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SwitchServiceCmdID* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SwitchServiceCmdID>(
    SwitchServiceCmdID_descriptor(), name, value);
}
enum OtherCmdID : int {
  CID_OTHER_UNKNOWN = 0,
  CID_OTHER_HEARTBEAT = 1793,
  CID_OTHER_STOP_RECV_PACKET = 1794,
  CID_OTHER_VALIDATE_REQ = 1795,
  CID_OTHER_VALIDATE_RSP = 1796,
  CID_OTHER_GET_DEVICE_TOKEN_REQ = 1797,
  CID_OTHER_GET_DEVICE_TOKEN_RSP = 1798,
  CID_OTHER_ROLE_SET = 1799,
  CID_OTHER_ONLINE_USER_INFO = 1800,
  CID_OTHER_MSG_SERV_INFO = 1801,
  CID_OTHER_USER_STATUS_UPDATE = 1802,
  CID_OTHER_USER_CNT_UPDATE = 1803,
  CID_OTHER_SERVER_KICK_USER = 1805,
  CID_OTHER_LOGIN_STATUS_NOTIFY = 1806,
  CID_OTHER_PUSH_TO_USER_REQ = 1807,
  CID_OTHER_PUSH_TO_USER_RSP = 1808,
  CID_OTHER_GET_SHIELD_REQ = 1809,
  CID_OTHER_GET_SHIELD_RSP = 1810,
  CID_OTHER_FILE_TRANSFER_REQ = 1841,
  CID_OTHER_FILE_TRANSFER_RSP = 1842,
  CID_OTHER_FILE_SERVER_IP_REQ = 1843,
  CID_OTHER_FILE_SERVER_IP_RSP = 1844,
  OtherCmdID_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  OtherCmdID_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool OtherCmdID_IsValid(int value);
constexpr OtherCmdID OtherCmdID_MIN = CID_OTHER_UNKNOWN;
constexpr OtherCmdID OtherCmdID_MAX = CID_OTHER_FILE_SERVER_IP_RSP;
constexpr int OtherCmdID_ARRAYSIZE = OtherCmdID_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OtherCmdID_descriptor();
template<typename T>
inline const std::string& OtherCmdID_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OtherCmdID>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OtherCmdID_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OtherCmdID_descriptor(), enum_t_value);
}
inline bool OtherCmdID_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OtherCmdID* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OtherCmdID>(
    OtherCmdID_descriptor(), name, value);
}
enum ResultType : int {
  REFUSE_REASON_NONE = 0,
  REFUSE_REASON_NO_MSG_SERVER = 1,
  REFUSE_REASON_MSG_SERVER_FULL = 2,
  REFUSE_REASON_NO_DB_SERVER = 3,
  REFUSE_REASON_NO_LOGIN_SERVER = 4,
  REFUSE_REASON_NO_ROUTE_SERVER = 5,
  REFUSE_REASON_DB_VALIDATE_FAILED = 6,
  REFUSE_REASON_VERSION_TOO_OLD = 7,
  ResultType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ResultType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ResultType_IsValid(int value);
constexpr ResultType ResultType_MIN = REFUSE_REASON_NONE;
constexpr ResultType ResultType_MAX = REFUSE_REASON_VERSION_TOO_OLD;
constexpr int ResultType_ARRAYSIZE = ResultType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResultType_descriptor();
template<typename T>
inline const std::string& ResultType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResultType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResultType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ResultType_descriptor(), enum_t_value);
}
inline bool ResultType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ResultType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResultType>(
    ResultType_descriptor(), name, value);
}
enum KickReasonType : int {
  KICK_REASON_NONE = 0,
  KICK_REASON_DUPLICATE_USER = 1,
  KICK_REASON_MOBILE_KICK = 2,
  KickReasonType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  KickReasonType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool KickReasonType_IsValid(int value);
constexpr KickReasonType KickReasonType_MIN = KICK_REASON_NONE;
constexpr KickReasonType KickReasonType_MAX = KICK_REASON_MOBILE_KICK;
constexpr int KickReasonType_ARRAYSIZE = KickReasonType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* KickReasonType_descriptor();
template<typename T>
inline const std::string& KickReasonType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, KickReasonType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function KickReasonType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    KickReasonType_descriptor(), enum_t_value);
}
inline bool KickReasonType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, KickReasonType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<KickReasonType>(
    KickReasonType_descriptor(), name, value);
}
enum OnlineListType : int {
  ONLINE_LIST_TYPE_NONE = 0,
  ONLINE_LIST_TYPE_FRIEND_LIST = 1,
  OnlineListType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  OnlineListType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool OnlineListType_IsValid(int value);
constexpr OnlineListType OnlineListType_MIN = ONLINE_LIST_TYPE_NONE;
constexpr OnlineListType OnlineListType_MAX = ONLINE_LIST_TYPE_FRIEND_LIST;
constexpr int OnlineListType_ARRAYSIZE = OnlineListType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OnlineListType_descriptor();
template<typename T>
inline const std::string& OnlineListType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OnlineListType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OnlineListType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OnlineListType_descriptor(), enum_t_value);
}
inline bool OnlineListType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OnlineListType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OnlineListType>(
    OnlineListType_descriptor(), name, value);
}
enum UserStatType : int {
  USER_STATUS_NONE = 0,
  USER_STATUS_ONLINE = 1,
  USER_STATUS_OFFLINE = 2,
  USER_STATUS_LEAVE = 3,
  UserStatType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  UserStatType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool UserStatType_IsValid(int value);
constexpr UserStatType UserStatType_MIN = USER_STATUS_NONE;
constexpr UserStatType UserStatType_MAX = USER_STATUS_LEAVE;
constexpr int UserStatType_ARRAYSIZE = UserStatType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UserStatType_descriptor();
template<typename T>
inline const std::string& UserStatType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UserStatType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UserStatType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UserStatType_descriptor(), enum_t_value);
}
inline bool UserStatType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UserStatType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UserStatType>(
    UserStatType_descriptor(), name, value);
}
enum SessionType : int {
  SESSION_TYPE_NONE = 0,
  SESSION_TYPE_SINGLE = 1,
  SESSION_TYPE_GROUP = 2,
  SessionType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  SessionType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool SessionType_IsValid(int value);
constexpr SessionType SessionType_MIN = SESSION_TYPE_NONE;
constexpr SessionType SessionType_MAX = SESSION_TYPE_GROUP;
constexpr int SessionType_ARRAYSIZE = SessionType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SessionType_descriptor();
template<typename T>
inline const std::string& SessionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SessionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SessionType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SessionType_descriptor(), enum_t_value);
}
inline bool SessionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SessionType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SessionType>(
    SessionType_descriptor(), name, value);
}
enum MsgType : int {
  MSG_TYPE_NONE = 0,
  MSG_TYPE_SINGLE_TEXT = 1,
  MSG_TYPE_SINGLE_AUDIO = 2,
  MSG_TYPE_GROUP_TEXT = 17,
  MSG_TYPE_GROUP_AUDIO = 18,
  MsgType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  MsgType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool MsgType_IsValid(int value);
constexpr MsgType MsgType_MIN = MSG_TYPE_NONE;
constexpr MsgType MsgType_MAX = MSG_TYPE_GROUP_AUDIO;
constexpr int MsgType_ARRAYSIZE = MsgType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MsgType_descriptor();
template<typename T>
inline const std::string& MsgType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MsgType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MsgType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MsgType_descriptor(), enum_t_value);
}
inline bool MsgType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MsgType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MsgType>(
    MsgType_descriptor(), name, value);
}
enum ClientType : int {
  CLIENT_TYPE_NONE = 0,
  CLIENT_TYPE_WINDOWS = 1,
  CLIENT_TYPE_MAC = 2,
  CLIENT_TYPE_IOS = 17,
  CLIENT_TYPE_ANDROID = 18,
  ClientType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ClientType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ClientType_IsValid(int value);
constexpr ClientType ClientType_MIN = CLIENT_TYPE_NONE;
constexpr ClientType ClientType_MAX = CLIENT_TYPE_ANDROID;
constexpr int ClientType_ARRAYSIZE = ClientType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ClientType_descriptor();
template<typename T>
inline const std::string& ClientType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ClientType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ClientType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ClientType_descriptor(), enum_t_value);
}
inline bool ClientType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ClientType>(
    ClientType_descriptor(), name, value);
}
enum GroupType : int {
  GROUP_TYPE_NONE = 0,
  GROUP_TYPE_NORMAL = 1,
  GROUP_TYPE_TMP = 2,
  GroupType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  GroupType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool GroupType_IsValid(int value);
constexpr GroupType GroupType_MIN = GROUP_TYPE_NONE;
constexpr GroupType GroupType_MAX = GROUP_TYPE_TMP;
constexpr int GroupType_ARRAYSIZE = GroupType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GroupType_descriptor();
template<typename T>
inline const std::string& GroupType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GroupType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GroupType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GroupType_descriptor(), enum_t_value);
}
inline bool GroupType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GroupType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GroupType>(
    GroupType_descriptor(), name, value);
}
enum GroupModifyType : int {
  GROUP_MODIFY_TYPE_NONE = 0,
  GROUP_MODIFY_TYPE_ADD = 1,
  GROUP_MODIFY_TYPE_DEL = 2,
  GroupModifyType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  GroupModifyType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool GroupModifyType_IsValid(int value);
constexpr GroupModifyType GroupModifyType_MIN = GROUP_MODIFY_TYPE_NONE;
constexpr GroupModifyType GroupModifyType_MAX = GROUP_MODIFY_TYPE_DEL;
constexpr int GroupModifyType_ARRAYSIZE = GroupModifyType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GroupModifyType_descriptor();
template<typename T>
inline const std::string& GroupModifyType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GroupModifyType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GroupModifyType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GroupModifyType_descriptor(), enum_t_value);
}
inline bool GroupModifyType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GroupModifyType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GroupModifyType>(
    GroupModifyType_descriptor(), name, value);
}
enum TransferFileType : int {
  FILE_TYPE_NONE = 0,
  FILE_TYPE_ONLINE = 1,
  FILE_TYPE_OFFLINE = 2,
  TransferFileType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TransferFileType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TransferFileType_IsValid(int value);
constexpr TransferFileType TransferFileType_MIN = FILE_TYPE_NONE;
constexpr TransferFileType TransferFileType_MAX = FILE_TYPE_OFFLINE;
constexpr int TransferFileType_ARRAYSIZE = TransferFileType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TransferFileType_descriptor();
template<typename T>
inline const std::string& TransferFileType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TransferFileType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TransferFileType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TransferFileType_descriptor(), enum_t_value);
}
inline bool TransferFileType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TransferFileType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TransferFileType>(
    TransferFileType_descriptor(), name, value);
}
enum ClientFileState : int {
  CLIENT_FILE_PEER_READY = 0,
  CLIENT_FILE_CANCEL = 1,
  CLIENT_FILE_REFUSE = 2,
  CLIENT_FILE_DONE = 3,
  ClientFileState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ClientFileState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ClientFileState_IsValid(int value);
constexpr ClientFileState ClientFileState_MIN = CLIENT_FILE_PEER_READY;
constexpr ClientFileState ClientFileState_MAX = CLIENT_FILE_DONE;
constexpr int ClientFileState_ARRAYSIZE = ClientFileState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ClientFileState_descriptor();
template<typename T>
inline const std::string& ClientFileState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ClientFileState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ClientFileState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ClientFileState_descriptor(), enum_t_value);
}
inline bool ClientFileState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientFileState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ClientFileState>(
    ClientFileState_descriptor(), name, value);
}
enum ClientFileRole : int {
  CLIENT_FILE_NONE = 0,
  CLIENT_REALTIME_SENDER = 1,
  CLIENT_REALTIME_RECVER = 2,
  CLIENT_OFFLINE_UPLOAD = 3,
  CLIENT_OFFLINE_DOWNLOAD = 4,
  ClientFileRole_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ClientFileRole_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ClientFileRole_IsValid(int value);
constexpr ClientFileRole ClientFileRole_MIN = CLIENT_FILE_NONE;
constexpr ClientFileRole ClientFileRole_MAX = CLIENT_OFFLINE_DOWNLOAD;
constexpr int ClientFileRole_ARRAYSIZE = ClientFileRole_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ClientFileRole_descriptor();
template<typename T>
inline const std::string& ClientFileRole_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ClientFileRole>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ClientFileRole_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ClientFileRole_descriptor(), enum_t_value);
}
inline bool ClientFileRole_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientFileRole* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ClientFileRole>(
    ClientFileRole_descriptor(), name, value);
}
enum FileServerError : int {
  FILE_SERVER_ERRNO_OK = 0,
  FILE_SERVER_ERRNO_CREATE_TASK_ID_ERROR = 1,
  FILE_SERVER_ERRNO_CREATE_TASK_ERROR = 2,
  FILE_SERVER_ERRNO_LOGIN_INVALID_TOKEN = 3,
  FILE_SERVER_ERRNO_INVALID_USER_FOR_TASK = 4,
  FILE_SERVER_ERRNO_PULL_DATA_WITH_INVALID_TASK_ID = 5,
  FILE_SERVER_ERRNO_PULL_DATA_ILLIEAGE_USER = 6,
  FILE_SERVER_ERRNO_PULL_DATA_MKDIR_ERROR = 7,
  FILE_SERVER_ERRNO_PULL_DATA_OPEN_FILE_ERROR = 8,
  FILE_SERVER_ERRNO_PULL_DATA_READ_FILE_HEADER_ERROR = 9,
  FILE_SERVER_ERRNO_PULL_DATA_ALLOC_MEM_ERROR = 10,
  FILE_SERVER_ERRNO_PULL_DATA_SEEK_OFFSET_ERROR = 11,
  FILE_SERVER_ERRNO_PULL_DATA_FINISHED = 12,
  FileServerError_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  FileServerError_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool FileServerError_IsValid(int value);
constexpr FileServerError FileServerError_MIN = FILE_SERVER_ERRNO_OK;
constexpr FileServerError FileServerError_MAX = FILE_SERVER_ERRNO_PULL_DATA_FINISHED;
constexpr int FileServerError_ARRAYSIZE = FileServerError_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FileServerError_descriptor();
template<typename T>
inline const std::string& FileServerError_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FileServerError>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FileServerError_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FileServerError_descriptor(), enum_t_value);
}
inline bool FileServerError_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FileServerError* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FileServerError>(
    FileServerError_descriptor(), name, value);
}
enum SessionStatusType : int {
  SESSION_STATUS_OK = 0,
  SESSION_STATUS_DELETE = 1,
  SessionStatusType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  SessionStatusType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool SessionStatusType_IsValid(int value);
constexpr SessionStatusType SessionStatusType_MIN = SESSION_STATUS_OK;
constexpr SessionStatusType SessionStatusType_MAX = SESSION_STATUS_DELETE;
constexpr int SessionStatusType_ARRAYSIZE = SessionStatusType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SessionStatusType_descriptor();
template<typename T>
inline const std::string& SessionStatusType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SessionStatusType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SessionStatusType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SessionStatusType_descriptor(), enum_t_value);
}
inline bool SessionStatusType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SessionStatusType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SessionStatusType>(
    SessionStatusType_descriptor(), name, value);
}
enum DepartmentStatusType : int {
  DEPT_STATUS_OK = 0,
  DEPT_STATUS_DELETE = 1,
  DepartmentStatusType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  DepartmentStatusType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool DepartmentStatusType_IsValid(int value);
constexpr DepartmentStatusType DepartmentStatusType_MIN = DEPT_STATUS_OK;
constexpr DepartmentStatusType DepartmentStatusType_MAX = DEPT_STATUS_DELETE;
constexpr int DepartmentStatusType_ARRAYSIZE = DepartmentStatusType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DepartmentStatusType_descriptor();
template<typename T>
inline const std::string& DepartmentStatusType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DepartmentStatusType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DepartmentStatusType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DepartmentStatusType_descriptor(), enum_t_value);
}
inline bool DepartmentStatusType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DepartmentStatusType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DepartmentStatusType>(
    DepartmentStatusType_descriptor(), name, value);
}
// ===================================================================

class IpAddr final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IM.BaseDefine.IpAddr) */ {
 public:
  inline IpAddr() : IpAddr(nullptr) {}
  ~IpAddr() override;
  explicit constexpr IpAddr(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IpAddr(const IpAddr& from);
  IpAddr(IpAddr&& from) noexcept
    : IpAddr() {
    *this = ::std::move(from);
  }

  inline IpAddr& operator=(const IpAddr& from) {
    CopyFrom(from);
    return *this;
  }
  inline IpAddr& operator=(IpAddr&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IpAddr& default_instance() {
    return *internal_default_instance();
  }
  static inline const IpAddr* internal_default_instance() {
    return reinterpret_cast<const IpAddr*>(
               &_IpAddr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(IpAddr& a, IpAddr& b) {
    a.Swap(&b);
  }
  inline void Swap(IpAddr* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IpAddr* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IpAddr* New() const final {
    return new IpAddr();
  }

  IpAddr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IpAddr>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IpAddr& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IpAddr& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IpAddr* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IM.BaseDefine.IpAddr";
  }
  protected:
  explicit IpAddr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpFieldNumber = 1,
    kPortFieldNumber = 2,
  };
  // string ip = 1;
  void clear_ip();
  const std::string& ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip();
  PROTOBUF_MUST_USE_RESULT std::string* release_ip();
  void set_allocated_ip(std::string* ip);
  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(const std::string& value);
  std::string* _internal_mutable_ip();
  public:

  // uint32 port = 2;
  void clear_port();
  ::PROTOBUF_NAMESPACE_ID::uint32 port() const;
  void set_port(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_port() const;
  void _internal_set_port(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.IpAddr)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_;
  ::PROTOBUF_NAMESPACE_ID::uint32 port_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_IM_2eBaseDefine_2eproto;
};
// -------------------------------------------------------------------

class UserInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IM.BaseDefine.UserInfo) */ {
 public:
  inline UserInfo() : UserInfo(nullptr) {}
  ~UserInfo() override;
  explicit constexpr UserInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserInfo(const UserInfo& from);
  UserInfo(UserInfo&& from) noexcept
    : UserInfo() {
    *this = ::std::move(from);
  }

  inline UserInfo& operator=(const UserInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserInfo& operator=(UserInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserInfo* internal_default_instance() {
    return reinterpret_cast<const UserInfo*>(
               &_UserInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(UserInfo& a, UserInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(UserInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UserInfo* New() const final {
    return new UserInfo();
  }

  UserInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UserInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UserInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IM.BaseDefine.UserInfo";
  }
  protected:
  explicit UserInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserNickNameFieldNumber = 3,
    kAvatarUrlFieldNumber = 4,
    kEmailFieldNumber = 6,
    kUserRealNameFieldNumber = 7,
    kUserTelFieldNumber = 8,
    kUserDomainFieldNumber = 9,
    kSignInfoFieldNumber = 11,
    kUserIdFieldNumber = 1,
    kUserGenderFieldNumber = 2,
    kDepartmentIdFieldNumber = 5,
    kStatusFieldNumber = 10,
  };
  // string user_nick_name = 3;
  void clear_user_nick_name();
  const std::string& user_nick_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_nick_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_nick_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_user_nick_name();
  void set_allocated_user_nick_name(std::string* user_nick_name);
  private:
  const std::string& _internal_user_nick_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_nick_name(const std::string& value);
  std::string* _internal_mutable_user_nick_name();
  public:

  // string avatar_url = 4;
  void clear_avatar_url();
  const std::string& avatar_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_avatar_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_avatar_url();
  PROTOBUF_MUST_USE_RESULT std::string* release_avatar_url();
  void set_allocated_avatar_url(std::string* avatar_url);
  private:
  const std::string& _internal_avatar_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_avatar_url(const std::string& value);
  std::string* _internal_mutable_avatar_url();
  public:

  // string email = 6;
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_MUST_USE_RESULT std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // string user_real_name = 7;
  void clear_user_real_name();
  const std::string& user_real_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_real_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_real_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_user_real_name();
  void set_allocated_user_real_name(std::string* user_real_name);
  private:
  const std::string& _internal_user_real_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_real_name(const std::string& value);
  std::string* _internal_mutable_user_real_name();
  public:

  // string user_tel = 8;
  void clear_user_tel();
  const std::string& user_tel() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_tel(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_tel();
  PROTOBUF_MUST_USE_RESULT std::string* release_user_tel();
  void set_allocated_user_tel(std::string* user_tel);
  private:
  const std::string& _internal_user_tel() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_tel(const std::string& value);
  std::string* _internal_mutable_user_tel();
  public:

  // string user_domain = 9;
  void clear_user_domain();
  const std::string& user_domain() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_domain(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_domain();
  PROTOBUF_MUST_USE_RESULT std::string* release_user_domain();
  void set_allocated_user_domain(std::string* user_domain);
  private:
  const std::string& _internal_user_domain() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_domain(const std::string& value);
  std::string* _internal_mutable_user_domain();
  public:

  // string sign_info = 11;
  void clear_sign_info();
  const std::string& sign_info() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sign_info(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sign_info();
  PROTOBUF_MUST_USE_RESULT std::string* release_sign_info();
  void set_allocated_sign_info(std::string* sign_info);
  private:
  const std::string& _internal_sign_info() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sign_info(const std::string& value);
  std::string* _internal_mutable_sign_info();
  public:

  // uint32 user_id = 1;
  void clear_user_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 user_id() const;
  void set_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_user_id() const;
  void _internal_set_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 user_gender = 2;
  void clear_user_gender();
  ::PROTOBUF_NAMESPACE_ID::uint32 user_gender() const;
  void set_user_gender(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_user_gender() const;
  void _internal_set_user_gender(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 department_id = 5;
  void clear_department_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 department_id() const;
  void set_department_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_department_id() const;
  void _internal_set_department_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 status = 10;
  void clear_status();
  ::PROTOBUF_NAMESPACE_ID::uint32 status() const;
  void set_status(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_status() const;
  void _internal_set_status(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.UserInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_nick_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr avatar_url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_real_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_tel_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_domain_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sign_info_;
  ::PROTOBUF_NAMESPACE_ID::uint32 user_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 user_gender_;
  ::PROTOBUF_NAMESPACE_ID::uint32 department_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_IM_2eBaseDefine_2eproto;
};
// -------------------------------------------------------------------

class ContactSessionInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IM.BaseDefine.ContactSessionInfo) */ {
 public:
  inline ContactSessionInfo() : ContactSessionInfo(nullptr) {}
  ~ContactSessionInfo() override;
  explicit constexpr ContactSessionInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContactSessionInfo(const ContactSessionInfo& from);
  ContactSessionInfo(ContactSessionInfo&& from) noexcept
    : ContactSessionInfo() {
    *this = ::std::move(from);
  }

  inline ContactSessionInfo& operator=(const ContactSessionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContactSessionInfo& operator=(ContactSessionInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContactSessionInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContactSessionInfo* internal_default_instance() {
    return reinterpret_cast<const ContactSessionInfo*>(
               &_ContactSessionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ContactSessionInfo& a, ContactSessionInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ContactSessionInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContactSessionInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ContactSessionInfo* New() const final {
    return new ContactSessionInfo();
  }

  ContactSessionInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ContactSessionInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ContactSessionInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ContactSessionInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContactSessionInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IM.BaseDefine.ContactSessionInfo";
  }
  protected:
  explicit ContactSessionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLatestMsgDataFieldNumber = 6,
    kSessionIdFieldNumber = 1,
    kSessionTypeFieldNumber = 2,
    kSessionStatusFieldNumber = 3,
    kUpdatedTimeFieldNumber = 4,
    kLatestMsgIdFieldNumber = 5,
    kLatestMsgTypeFieldNumber = 7,
    kLatestMsgFromUserIdFieldNumber = 8,
  };
  // bytes latest_msg_data = 6;
  void clear_latest_msg_data();
  const std::string& latest_msg_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_latest_msg_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_latest_msg_data();
  PROTOBUF_MUST_USE_RESULT std::string* release_latest_msg_data();
  void set_allocated_latest_msg_data(std::string* latest_msg_data);
  private:
  const std::string& _internal_latest_msg_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_latest_msg_data(const std::string& value);
  std::string* _internal_mutable_latest_msg_data();
  public:

  // uint32 session_id = 1;
  void clear_session_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 session_id() const;
  void set_session_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_session_id() const;
  void _internal_set_session_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // .IM.BaseDefine.SessionType session_type = 2;
  void clear_session_type();
  ::IM::BaseDefine::SessionType session_type() const;
  void set_session_type(::IM::BaseDefine::SessionType value);
  private:
  ::IM::BaseDefine::SessionType _internal_session_type() const;
  void _internal_set_session_type(::IM::BaseDefine::SessionType value);
  public:

  // .IM.BaseDefine.SessionStatusType session_status = 3;
  void clear_session_status();
  ::IM::BaseDefine::SessionStatusType session_status() const;
  void set_session_status(::IM::BaseDefine::SessionStatusType value);
  private:
  ::IM::BaseDefine::SessionStatusType _internal_session_status() const;
  void _internal_set_session_status(::IM::BaseDefine::SessionStatusType value);
  public:

  // uint32 updated_time = 4;
  void clear_updated_time();
  ::PROTOBUF_NAMESPACE_ID::uint32 updated_time() const;
  void set_updated_time(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_updated_time() const;
  void _internal_set_updated_time(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 latest_msg_id = 5;
  void clear_latest_msg_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 latest_msg_id() const;
  void set_latest_msg_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_latest_msg_id() const;
  void _internal_set_latest_msg_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // .IM.BaseDefine.MsgType latest_msg_type = 7;
  void clear_latest_msg_type();
  ::IM::BaseDefine::MsgType latest_msg_type() const;
  void set_latest_msg_type(::IM::BaseDefine::MsgType value);
  private:
  ::IM::BaseDefine::MsgType _internal_latest_msg_type() const;
  void _internal_set_latest_msg_type(::IM::BaseDefine::MsgType value);
  public:

  // uint32 latest_msg_from_user_id = 8;
  void clear_latest_msg_from_user_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 latest_msg_from_user_id() const;
  void set_latest_msg_from_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_latest_msg_from_user_id() const;
  void _internal_set_latest_msg_from_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.ContactSessionInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr latest_msg_data_;
  ::PROTOBUF_NAMESPACE_ID::uint32 session_id_;
  int session_type_;
  int session_status_;
  ::PROTOBUF_NAMESPACE_ID::uint32 updated_time_;
  ::PROTOBUF_NAMESPACE_ID::uint32 latest_msg_id_;
  int latest_msg_type_;
  ::PROTOBUF_NAMESPACE_ID::uint32 latest_msg_from_user_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_IM_2eBaseDefine_2eproto;
};
// -------------------------------------------------------------------

class UserStat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IM.BaseDefine.UserStat) */ {
 public:
  inline UserStat() : UserStat(nullptr) {}
  ~UserStat() override;
  explicit constexpr UserStat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserStat(const UserStat& from);
  UserStat(UserStat&& from) noexcept
    : UserStat() {
    *this = ::std::move(from);
  }

  inline UserStat& operator=(const UserStat& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserStat& operator=(UserStat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserStat& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserStat* internal_default_instance() {
    return reinterpret_cast<const UserStat*>(
               &_UserStat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(UserStat& a, UserStat& b) {
    a.Swap(&b);
  }
  inline void Swap(UserStat* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserStat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UserStat* New() const final {
    return new UserStat();
  }

  UserStat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UserStat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserStat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UserStat& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserStat* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IM.BaseDefine.UserStat";
  }
  protected:
  explicit UserStat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // uint32 user_id = 1;
  void clear_user_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 user_id() const;
  void set_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_user_id() const;
  void _internal_set_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // .IM.BaseDefine.UserStatType status = 2;
  void clear_status();
  ::IM::BaseDefine::UserStatType status() const;
  void set_status(::IM::BaseDefine::UserStatType value);
  private:
  ::IM::BaseDefine::UserStatType _internal_status() const;
  void _internal_set_status(::IM::BaseDefine::UserStatType value);
  public:

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.UserStat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 user_id_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_IM_2eBaseDefine_2eproto;
};
// -------------------------------------------------------------------

class ServerUserStat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IM.BaseDefine.ServerUserStat) */ {
 public:
  inline ServerUserStat() : ServerUserStat(nullptr) {}
  ~ServerUserStat() override;
  explicit constexpr ServerUserStat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServerUserStat(const ServerUserStat& from);
  ServerUserStat(ServerUserStat&& from) noexcept
    : ServerUserStat() {
    *this = ::std::move(from);
  }

  inline ServerUserStat& operator=(const ServerUserStat& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerUserStat& operator=(ServerUserStat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServerUserStat& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServerUserStat* internal_default_instance() {
    return reinterpret_cast<const ServerUserStat*>(
               &_ServerUserStat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ServerUserStat& a, ServerUserStat& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerUserStat* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerUserStat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ServerUserStat* New() const final {
    return new ServerUserStat();
  }

  ServerUserStat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ServerUserStat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServerUserStat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ServerUserStat& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerUserStat* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IM.BaseDefine.ServerUserStat";
  }
  protected:
  explicit ServerUserStat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kStatusFieldNumber = 2,
    kClientTypeFieldNumber = 3,
  };
  // uint32 user_id = 1;
  void clear_user_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 user_id() const;
  void set_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_user_id() const;
  void _internal_set_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // .IM.BaseDefine.UserStatType status = 2;
  void clear_status();
  ::IM::BaseDefine::UserStatType status() const;
  void set_status(::IM::BaseDefine::UserStatType value);
  private:
  ::IM::BaseDefine::UserStatType _internal_status() const;
  void _internal_set_status(::IM::BaseDefine::UserStatType value);
  public:

  // .IM.BaseDefine.ClientType client_type = 3;
  void clear_client_type();
  ::IM::BaseDefine::ClientType client_type() const;
  void set_client_type(::IM::BaseDefine::ClientType value);
  private:
  ::IM::BaseDefine::ClientType _internal_client_type() const;
  void _internal_set_client_type(::IM::BaseDefine::ClientType value);
  public:

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.ServerUserStat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 user_id_;
  int status_;
  int client_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_IM_2eBaseDefine_2eproto;
};
// -------------------------------------------------------------------

class UnreadInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IM.BaseDefine.UnreadInfo) */ {
 public:
  inline UnreadInfo() : UnreadInfo(nullptr) {}
  ~UnreadInfo() override;
  explicit constexpr UnreadInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnreadInfo(const UnreadInfo& from);
  UnreadInfo(UnreadInfo&& from) noexcept
    : UnreadInfo() {
    *this = ::std::move(from);
  }

  inline UnreadInfo& operator=(const UnreadInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnreadInfo& operator=(UnreadInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnreadInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnreadInfo* internal_default_instance() {
    return reinterpret_cast<const UnreadInfo*>(
               &_UnreadInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(UnreadInfo& a, UnreadInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(UnreadInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnreadInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UnreadInfo* New() const final {
    return new UnreadInfo();
  }

  UnreadInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UnreadInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnreadInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UnreadInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnreadInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IM.BaseDefine.UnreadInfo";
  }
  protected:
  explicit UnreadInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLatestMsgDataFieldNumber = 5,
    kSessionIdFieldNumber = 1,
    kSessionTypeFieldNumber = 2,
    kUnreadCntFieldNumber = 3,
    kLatestMsgIdFieldNumber = 4,
    kLatestMsgTypeFieldNumber = 6,
    kLatestMsgFromUserIdFieldNumber = 7,
  };
  // bytes latest_msg_data = 5;
  void clear_latest_msg_data();
  const std::string& latest_msg_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_latest_msg_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_latest_msg_data();
  PROTOBUF_MUST_USE_RESULT std::string* release_latest_msg_data();
  void set_allocated_latest_msg_data(std::string* latest_msg_data);
  private:
  const std::string& _internal_latest_msg_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_latest_msg_data(const std::string& value);
  std::string* _internal_mutable_latest_msg_data();
  public:

  // uint32 session_id = 1;
  void clear_session_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 session_id() const;
  void set_session_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_session_id() const;
  void _internal_set_session_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // .IM.BaseDefine.SessionType session_type = 2;
  void clear_session_type();
  ::IM::BaseDefine::SessionType session_type() const;
  void set_session_type(::IM::BaseDefine::SessionType value);
  private:
  ::IM::BaseDefine::SessionType _internal_session_type() const;
  void _internal_set_session_type(::IM::BaseDefine::SessionType value);
  public:

  // uint32 unread_cnt = 3;
  void clear_unread_cnt();
  ::PROTOBUF_NAMESPACE_ID::uint32 unread_cnt() const;
  void set_unread_cnt(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_unread_cnt() const;
  void _internal_set_unread_cnt(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 latest_msg_id = 4;
  void clear_latest_msg_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 latest_msg_id() const;
  void set_latest_msg_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_latest_msg_id() const;
  void _internal_set_latest_msg_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // .IM.BaseDefine.MsgType latest_msg_type = 6;
  void clear_latest_msg_type();
  ::IM::BaseDefine::MsgType latest_msg_type() const;
  void set_latest_msg_type(::IM::BaseDefine::MsgType value);
  private:
  ::IM::BaseDefine::MsgType _internal_latest_msg_type() const;
  void _internal_set_latest_msg_type(::IM::BaseDefine::MsgType value);
  public:

  // uint32 latest_msg_from_user_id = 7;
  void clear_latest_msg_from_user_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 latest_msg_from_user_id() const;
  void set_latest_msg_from_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_latest_msg_from_user_id() const;
  void _internal_set_latest_msg_from_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.UnreadInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr latest_msg_data_;
  ::PROTOBUF_NAMESPACE_ID::uint32 session_id_;
  int session_type_;
  ::PROTOBUF_NAMESPACE_ID::uint32 unread_cnt_;
  ::PROTOBUF_NAMESPACE_ID::uint32 latest_msg_id_;
  int latest_msg_type_;
  ::PROTOBUF_NAMESPACE_ID::uint32 latest_msg_from_user_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_IM_2eBaseDefine_2eproto;
};
// -------------------------------------------------------------------

class MsgInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IM.BaseDefine.MsgInfo) */ {
 public:
  inline MsgInfo() : MsgInfo(nullptr) {}
  ~MsgInfo() override;
  explicit constexpr MsgInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgInfo(const MsgInfo& from);
  MsgInfo(MsgInfo&& from) noexcept
    : MsgInfo() {
    *this = ::std::move(from);
  }

  inline MsgInfo& operator=(const MsgInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgInfo& operator=(MsgInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgInfo* internal_default_instance() {
    return reinterpret_cast<const MsgInfo*>(
               &_MsgInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(MsgInfo& a, MsgInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MsgInfo* New() const final {
    return new MsgInfo();
  }

  MsgInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MsgInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MsgInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IM.BaseDefine.MsgInfo";
  }
  protected:
  explicit MsgInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgDataFieldNumber = 5,
    kMsgIdFieldNumber = 1,
    kFromSessionIdFieldNumber = 2,
    kCreateTimeFieldNumber = 3,
    kMsgTypeFieldNumber = 4,
  };
  // bytes msg_data = 5;
  void clear_msg_data();
  const std::string& msg_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg_data();
  PROTOBUF_MUST_USE_RESULT std::string* release_msg_data();
  void set_allocated_msg_data(std::string* msg_data);
  private:
  const std::string& _internal_msg_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg_data(const std::string& value);
  std::string* _internal_mutable_msg_data();
  public:

  // uint32 msg_id = 1;
  void clear_msg_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 msg_id() const;
  void set_msg_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_msg_id() const;
  void _internal_set_msg_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 from_session_id = 2;
  void clear_from_session_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 from_session_id() const;
  void set_from_session_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_from_session_id() const;
  void _internal_set_from_session_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 create_time = 3;
  void clear_create_time();
  ::PROTOBUF_NAMESPACE_ID::uint32 create_time() const;
  void set_create_time(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_create_time() const;
  void _internal_set_create_time(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // .IM.BaseDefine.MsgType msg_type = 4;
  void clear_msg_type();
  ::IM::BaseDefine::MsgType msg_type() const;
  void set_msg_type(::IM::BaseDefine::MsgType value);
  private:
  ::IM::BaseDefine::MsgType _internal_msg_type() const;
  void _internal_set_msg_type(::IM::BaseDefine::MsgType value);
  public:

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.MsgInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_data_;
  ::PROTOBUF_NAMESPACE_ID::uint32 msg_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 from_session_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 create_time_;
  int msg_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_IM_2eBaseDefine_2eproto;
};
// -------------------------------------------------------------------

class GroupVersionInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IM.BaseDefine.GroupVersionInfo) */ {
 public:
  inline GroupVersionInfo() : GroupVersionInfo(nullptr) {}
  ~GroupVersionInfo() override;
  explicit constexpr GroupVersionInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GroupVersionInfo(const GroupVersionInfo& from);
  GroupVersionInfo(GroupVersionInfo&& from) noexcept
    : GroupVersionInfo() {
    *this = ::std::move(from);
  }

  inline GroupVersionInfo& operator=(const GroupVersionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline GroupVersionInfo& operator=(GroupVersionInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GroupVersionInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const GroupVersionInfo* internal_default_instance() {
    return reinterpret_cast<const GroupVersionInfo*>(
               &_GroupVersionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GroupVersionInfo& a, GroupVersionInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(GroupVersionInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GroupVersionInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GroupVersionInfo* New() const final {
    return new GroupVersionInfo();
  }

  GroupVersionInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GroupVersionInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GroupVersionInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GroupVersionInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GroupVersionInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IM.BaseDefine.GroupVersionInfo";
  }
  protected:
  explicit GroupVersionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupIdFieldNumber = 1,
    kVersionFieldNumber = 2,
  };
  // uint32 group_id = 1;
  void clear_group_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 group_id() const;
  void set_group_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_group_id() const;
  void _internal_set_group_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 version = 2;
  void clear_version();
  ::PROTOBUF_NAMESPACE_ID::uint32 version() const;
  void set_version(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_version() const;
  void _internal_set_version(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.GroupVersionInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 group_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 version_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_IM_2eBaseDefine_2eproto;
};
// -------------------------------------------------------------------

class GroupInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IM.BaseDefine.GroupInfo) */ {
 public:
  inline GroupInfo() : GroupInfo(nullptr) {}
  ~GroupInfo() override;
  explicit constexpr GroupInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GroupInfo(const GroupInfo& from);
  GroupInfo(GroupInfo&& from) noexcept
    : GroupInfo() {
    *this = ::std::move(from);
  }

  inline GroupInfo& operator=(const GroupInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline GroupInfo& operator=(GroupInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GroupInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const GroupInfo* internal_default_instance() {
    return reinterpret_cast<const GroupInfo*>(
               &_GroupInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(GroupInfo& a, GroupInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(GroupInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GroupInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GroupInfo* New() const final {
    return new GroupInfo();
  }

  GroupInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GroupInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GroupInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GroupInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GroupInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IM.BaseDefine.GroupInfo";
  }
  protected:
  explicit GroupInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupMemberListFieldNumber = 8,
    kGroupNameFieldNumber = 3,
    kGroupAvatarFieldNumber = 4,
    kGroupIdFieldNumber = 1,
    kVersionFieldNumber = 2,
    kGroupCreatorIdFieldNumber = 5,
    kGroupTypeFieldNumber = 6,
    kShieldStatusFieldNumber = 7,
  };
  // repeated uint32 group_member_list = 8;
  int group_member_list_size() const;
  private:
  int _internal_group_member_list_size() const;
  public:
  void clear_group_member_list();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_group_member_list(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      _internal_group_member_list() const;
  void _internal_add_group_member_list(::PROTOBUF_NAMESPACE_ID::uint32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      _internal_mutable_group_member_list();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint32 group_member_list(int index) const;
  void set_group_member_list(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value);
  void add_group_member_list(::PROTOBUF_NAMESPACE_ID::uint32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      group_member_list() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      mutable_group_member_list();

  // string group_name = 3;
  void clear_group_name();
  const std::string& group_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_group_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_group_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_group_name();
  void set_allocated_group_name(std::string* group_name);
  private:
  const std::string& _internal_group_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_group_name(const std::string& value);
  std::string* _internal_mutable_group_name();
  public:

  // string group_avatar = 4;
  void clear_group_avatar();
  const std::string& group_avatar() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_group_avatar(ArgT0&& arg0, ArgT... args);
  std::string* mutable_group_avatar();
  PROTOBUF_MUST_USE_RESULT std::string* release_group_avatar();
  void set_allocated_group_avatar(std::string* group_avatar);
  private:
  const std::string& _internal_group_avatar() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_group_avatar(const std::string& value);
  std::string* _internal_mutable_group_avatar();
  public:

  // uint32 group_id = 1;
  void clear_group_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 group_id() const;
  void set_group_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_group_id() const;
  void _internal_set_group_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 version = 2;
  void clear_version();
  ::PROTOBUF_NAMESPACE_ID::uint32 version() const;
  void set_version(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_version() const;
  void _internal_set_version(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 group_creator_id = 5;
  void clear_group_creator_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 group_creator_id() const;
  void set_group_creator_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_group_creator_id() const;
  void _internal_set_group_creator_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // .IM.BaseDefine.GroupType group_type = 6;
  void clear_group_type();
  ::IM::BaseDefine::GroupType group_type() const;
  void set_group_type(::IM::BaseDefine::GroupType value);
  private:
  ::IM::BaseDefine::GroupType _internal_group_type() const;
  void _internal_set_group_type(::IM::BaseDefine::GroupType value);
  public:

  // uint32 shield_status = 7;
  void clear_shield_status();
  ::PROTOBUF_NAMESPACE_ID::uint32 shield_status() const;
  void set_shield_status(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_shield_status() const;
  void _internal_set_shield_status(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.GroupInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 > group_member_list_;
  mutable std::atomic<int> _group_member_list_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr group_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr group_avatar_;
  ::PROTOBUF_NAMESPACE_ID::uint32 group_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 version_;
  ::PROTOBUF_NAMESPACE_ID::uint32 group_creator_id_;
  int group_type_;
  ::PROTOBUF_NAMESPACE_ID::uint32 shield_status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_IM_2eBaseDefine_2eproto;
};
// -------------------------------------------------------------------

class UserTokenInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IM.BaseDefine.UserTokenInfo) */ {
 public:
  inline UserTokenInfo() : UserTokenInfo(nullptr) {}
  ~UserTokenInfo() override;
  explicit constexpr UserTokenInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserTokenInfo(const UserTokenInfo& from);
  UserTokenInfo(UserTokenInfo&& from) noexcept
    : UserTokenInfo() {
    *this = ::std::move(from);
  }

  inline UserTokenInfo& operator=(const UserTokenInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserTokenInfo& operator=(UserTokenInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserTokenInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserTokenInfo* internal_default_instance() {
    return reinterpret_cast<const UserTokenInfo*>(
               &_UserTokenInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(UserTokenInfo& a, UserTokenInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(UserTokenInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserTokenInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UserTokenInfo* New() const final {
    return new UserTokenInfo();
  }

  UserTokenInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UserTokenInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserTokenInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UserTokenInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserTokenInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IM.BaseDefine.UserTokenInfo";
  }
  protected:
  explicit UserTokenInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 3,
    kUserIdFieldNumber = 1,
    kUserTypeFieldNumber = 2,
    kPushCountFieldNumber = 4,
    kPushTypeFieldNumber = 5,
  };
  // string token = 3;
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_MUST_USE_RESULT std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // uint32 user_id = 1;
  void clear_user_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 user_id() const;
  void set_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_user_id() const;
  void _internal_set_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // .IM.BaseDefine.ClientType user_type = 2;
  void clear_user_type();
  ::IM::BaseDefine::ClientType user_type() const;
  void set_user_type(::IM::BaseDefine::ClientType value);
  private:
  ::IM::BaseDefine::ClientType _internal_user_type() const;
  void _internal_set_user_type(::IM::BaseDefine::ClientType value);
  public:

  // uint32 push_count = 4;
  void clear_push_count();
  ::PROTOBUF_NAMESPACE_ID::uint32 push_count() const;
  void set_push_count(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_push_count() const;
  void _internal_set_push_count(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 push_type = 5;
  void clear_push_type();
  ::PROTOBUF_NAMESPACE_ID::uint32 push_type() const;
  void set_push_type(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_push_type() const;
  void _internal_set_push_type(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.UserTokenInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
  ::PROTOBUF_NAMESPACE_ID::uint32 user_id_;
  int user_type_;
  ::PROTOBUF_NAMESPACE_ID::uint32 push_count_;
  ::PROTOBUF_NAMESPACE_ID::uint32 push_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_IM_2eBaseDefine_2eproto;
};
// -------------------------------------------------------------------

class PushResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IM.BaseDefine.PushResult) */ {
 public:
  inline PushResult() : PushResult(nullptr) {}
  ~PushResult() override;
  explicit constexpr PushResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PushResult(const PushResult& from);
  PushResult(PushResult&& from) noexcept
    : PushResult() {
    *this = ::std::move(from);
  }

  inline PushResult& operator=(const PushResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline PushResult& operator=(PushResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PushResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const PushResult* internal_default_instance() {
    return reinterpret_cast<const PushResult*>(
               &_PushResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(PushResult& a, PushResult& b) {
    a.Swap(&b);
  }
  inline void Swap(PushResult* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PushResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PushResult* New() const final {
    return new PushResult();
  }

  PushResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PushResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PushResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PushResult& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PushResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IM.BaseDefine.PushResult";
  }
  protected:
  explicit PushResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserTokenFieldNumber = 1,
    kResultCodeFieldNumber = 2,
  };
  // string user_token = 1;
  void clear_user_token();
  const std::string& user_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_token();
  PROTOBUF_MUST_USE_RESULT std::string* release_user_token();
  void set_allocated_user_token(std::string* user_token);
  private:
  const std::string& _internal_user_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_token(const std::string& value);
  std::string* _internal_mutable_user_token();
  public:

  // uint32 result_code = 2;
  void clear_result_code();
  ::PROTOBUF_NAMESPACE_ID::uint32 result_code() const;
  void set_result_code(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_result_code() const;
  void _internal_set_result_code(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.PushResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_token_;
  ::PROTOBUF_NAMESPACE_ID::uint32 result_code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_IM_2eBaseDefine_2eproto;
};
// -------------------------------------------------------------------

class ShieldStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IM.BaseDefine.ShieldStatus) */ {
 public:
  inline ShieldStatus() : ShieldStatus(nullptr) {}
  ~ShieldStatus() override;
  explicit constexpr ShieldStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShieldStatus(const ShieldStatus& from);
  ShieldStatus(ShieldStatus&& from) noexcept
    : ShieldStatus() {
    *this = ::std::move(from);
  }

  inline ShieldStatus& operator=(const ShieldStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShieldStatus& operator=(ShieldStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShieldStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShieldStatus* internal_default_instance() {
    return reinterpret_cast<const ShieldStatus*>(
               &_ShieldStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ShieldStatus& a, ShieldStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(ShieldStatus* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShieldStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ShieldStatus* New() const final {
    return new ShieldStatus();
  }

  ShieldStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ShieldStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShieldStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ShieldStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShieldStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IM.BaseDefine.ShieldStatus";
  }
  protected:
  explicit ShieldStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kGroupIdFieldNumber = 2,
    kShieldStatusFieldNumber = 3,
  };
  // uint32 user_id = 1;
  void clear_user_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 user_id() const;
  void set_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_user_id() const;
  void _internal_set_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 group_id = 2;
  void clear_group_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 group_id() const;
  void set_group_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_group_id() const;
  void _internal_set_group_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 shield_status = 3;
  void clear_shield_status();
  ::PROTOBUF_NAMESPACE_ID::uint32 shield_status() const;
  void set_shield_status(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_shield_status() const;
  void _internal_set_shield_status(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.ShieldStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 user_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 group_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 shield_status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_IM_2eBaseDefine_2eproto;
};
// -------------------------------------------------------------------

class OfflineFileInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IM.BaseDefine.OfflineFileInfo) */ {
 public:
  inline OfflineFileInfo() : OfflineFileInfo(nullptr) {}
  ~OfflineFileInfo() override;
  explicit constexpr OfflineFileInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OfflineFileInfo(const OfflineFileInfo& from);
  OfflineFileInfo(OfflineFileInfo&& from) noexcept
    : OfflineFileInfo() {
    *this = ::std::move(from);
  }

  inline OfflineFileInfo& operator=(const OfflineFileInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline OfflineFileInfo& operator=(OfflineFileInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OfflineFileInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const OfflineFileInfo* internal_default_instance() {
    return reinterpret_cast<const OfflineFileInfo*>(
               &_OfflineFileInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(OfflineFileInfo& a, OfflineFileInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(OfflineFileInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OfflineFileInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OfflineFileInfo* New() const final {
    return new OfflineFileInfo();
  }

  OfflineFileInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OfflineFileInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OfflineFileInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OfflineFileInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OfflineFileInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IM.BaseDefine.OfflineFileInfo";
  }
  protected:
  explicit OfflineFileInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskIdFieldNumber = 2,
    kFileNameFieldNumber = 3,
    kFromUserIdFieldNumber = 1,
    kFileSizeFieldNumber = 4,
  };
  // string task_id = 2;
  void clear_task_id();
  const std::string& task_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_task_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_task_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_task_id();
  void set_allocated_task_id(std::string* task_id);
  private:
  const std::string& _internal_task_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_task_id(const std::string& value);
  std::string* _internal_mutable_task_id();
  public:

  // string file_name = 3;
  void clear_file_name();
  const std::string& file_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_file_name();
  void set_allocated_file_name(std::string* file_name);
  private:
  const std::string& _internal_file_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_name(const std::string& value);
  std::string* _internal_mutable_file_name();
  public:

  // uint32 from_user_id = 1;
  void clear_from_user_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 from_user_id() const;
  void set_from_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_from_user_id() const;
  void _internal_set_from_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 file_size = 4;
  void clear_file_size();
  ::PROTOBUF_NAMESPACE_ID::uint32 file_size() const;
  void set_file_size(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_file_size() const;
  void _internal_set_file_size(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.OfflineFileInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr task_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_name_;
  ::PROTOBUF_NAMESPACE_ID::uint32 from_user_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 file_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_IM_2eBaseDefine_2eproto;
};
// -------------------------------------------------------------------

class DepartInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IM.BaseDefine.DepartInfo) */ {
 public:
  inline DepartInfo() : DepartInfo(nullptr) {}
  ~DepartInfo() override;
  explicit constexpr DepartInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DepartInfo(const DepartInfo& from);
  DepartInfo(DepartInfo&& from) noexcept
    : DepartInfo() {
    *this = ::std::move(from);
  }

  inline DepartInfo& operator=(const DepartInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline DepartInfo& operator=(DepartInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DepartInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const DepartInfo* internal_default_instance() {
    return reinterpret_cast<const DepartInfo*>(
               &_DepartInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(DepartInfo& a, DepartInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(DepartInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DepartInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DepartInfo* New() const final {
    return new DepartInfo();
  }

  DepartInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DepartInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DepartInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DepartInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DepartInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IM.BaseDefine.DepartInfo";
  }
  protected:
  explicit DepartInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeptNameFieldNumber = 3,
    kDeptIdFieldNumber = 1,
    kPriorityFieldNumber = 2,
    kParentDeptIdFieldNumber = 4,
    kDeptStatusFieldNumber = 5,
  };
  // string dept_name = 3;
  void clear_dept_name();
  const std::string& dept_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dept_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dept_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_dept_name();
  void set_allocated_dept_name(std::string* dept_name);
  private:
  const std::string& _internal_dept_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dept_name(const std::string& value);
  std::string* _internal_mutable_dept_name();
  public:

  // uint32 dept_id = 1;
  void clear_dept_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 dept_id() const;
  void set_dept_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_dept_id() const;
  void _internal_set_dept_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 priority = 2;
  void clear_priority();
  ::PROTOBUF_NAMESPACE_ID::uint32 priority() const;
  void set_priority(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_priority() const;
  void _internal_set_priority(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 parent_dept_id = 4;
  void clear_parent_dept_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 parent_dept_id() const;
  void set_parent_dept_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_parent_dept_id() const;
  void _internal_set_parent_dept_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // .IM.BaseDefine.DepartmentStatusType dept_status = 5;
  void clear_dept_status();
  ::IM::BaseDefine::DepartmentStatusType dept_status() const;
  void set_dept_status(::IM::BaseDefine::DepartmentStatusType value);
  private:
  ::IM::BaseDefine::DepartmentStatusType _internal_dept_status() const;
  void _internal_set_dept_status(::IM::BaseDefine::DepartmentStatusType value);
  public:

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.DepartInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dept_name_;
  ::PROTOBUF_NAMESPACE_ID::uint32 dept_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 priority_;
  ::PROTOBUF_NAMESPACE_ID::uint32 parent_dept_id_;
  int dept_status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_IM_2eBaseDefine_2eproto;
};
// -------------------------------------------------------------------

class PushShieldStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IM.BaseDefine.PushShieldStatus) */ {
 public:
  inline PushShieldStatus() : PushShieldStatus(nullptr) {}
  ~PushShieldStatus() override;
  explicit constexpr PushShieldStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PushShieldStatus(const PushShieldStatus& from);
  PushShieldStatus(PushShieldStatus&& from) noexcept
    : PushShieldStatus() {
    *this = ::std::move(from);
  }

  inline PushShieldStatus& operator=(const PushShieldStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline PushShieldStatus& operator=(PushShieldStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PushShieldStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const PushShieldStatus* internal_default_instance() {
    return reinterpret_cast<const PushShieldStatus*>(
               &_PushShieldStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(PushShieldStatus& a, PushShieldStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(PushShieldStatus* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PushShieldStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PushShieldStatus* New() const final {
    return new PushShieldStatus();
  }

  PushShieldStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PushShieldStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PushShieldStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PushShieldStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PushShieldStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IM.BaseDefine.PushShieldStatus";
  }
  protected:
  explicit PushShieldStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kShieldStatusFieldNumber = 2,
  };
  // uint32 user_id = 1;
  void clear_user_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 user_id() const;
  void set_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_user_id() const;
  void _internal_set_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 shield_status = 2;
  void clear_shield_status();
  ::PROTOBUF_NAMESPACE_ID::uint32 shield_status() const;
  void set_shield_status(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_shield_status() const;
  void _internal_set_shield_status(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.PushShieldStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 user_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 shield_status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_IM_2eBaseDefine_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// IpAddr

// string ip = 1;
inline void IpAddr::clear_ip() {
  ip_.ClearToEmpty();
}
inline const std::string& IpAddr::ip() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.IpAddr.ip)
  return _internal_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IpAddr::set_ip(ArgT0&& arg0, ArgT... args) {
 
 ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IM.BaseDefine.IpAddr.ip)
}
inline std::string* IpAddr::mutable_ip() {
  std::string* _s = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.IpAddr.ip)
  return _s;
}
inline const std::string& IpAddr::_internal_ip() const {
  return ip_.Get();
}
inline void IpAddr::_internal_set_ip(const std::string& value) {
  
  ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* IpAddr::_internal_mutable_ip() {
  
  return ip_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* IpAddr::release_ip() {
  // @@protoc_insertion_point(field_release:IM.BaseDefine.IpAddr.ip)
  return ip_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void IpAddr::set_allocated_ip(std::string* ip) {
  if (ip != nullptr) {
    
  } else {
    
  }
  ip_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ip,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.IpAddr.ip)
}

// uint32 port = 2;
inline void IpAddr::clear_port() {
  port_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IpAddr::_internal_port() const {
  return port_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IpAddr::port() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.IpAddr.port)
  return _internal_port();
}
inline void IpAddr::_internal_set_port(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  port_ = value;
}
inline void IpAddr::set_port(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.IpAddr.port)
}

// -------------------------------------------------------------------

// UserInfo

// uint32 user_id = 1;
inline void UserInfo::clear_user_id() {
  user_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UserInfo::_internal_user_id() const {
  return user_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UserInfo::user_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserInfo.user_id)
  return _internal_user_id();
}
inline void UserInfo::_internal_set_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  user_id_ = value;
}
inline void UserInfo::set_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserInfo.user_id)
}

// uint32 user_gender = 2;
inline void UserInfo::clear_user_gender() {
  user_gender_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UserInfo::_internal_user_gender() const {
  return user_gender_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UserInfo::user_gender() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserInfo.user_gender)
  return _internal_user_gender();
}
inline void UserInfo::_internal_set_user_gender(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  user_gender_ = value;
}
inline void UserInfo::set_user_gender(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_user_gender(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserInfo.user_gender)
}

// string user_nick_name = 3;
inline void UserInfo::clear_user_nick_name() {
  user_nick_name_.ClearToEmpty();
}
inline const std::string& UserInfo::user_nick_name() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserInfo.user_nick_name)
  return _internal_user_nick_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfo::set_user_nick_name(ArgT0&& arg0, ArgT... args) {
 
 user_nick_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserInfo.user_nick_name)
}
inline std::string* UserInfo::mutable_user_nick_name() {
  std::string* _s = _internal_mutable_user_nick_name();
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.UserInfo.user_nick_name)
  return _s;
}
inline const std::string& UserInfo::_internal_user_nick_name() const {
  return user_nick_name_.Get();
}
inline void UserInfo::_internal_set_user_nick_name(const std::string& value) {
  
  user_nick_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UserInfo::_internal_mutable_user_nick_name() {
  
  return user_nick_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UserInfo::release_user_nick_name() {
  // @@protoc_insertion_point(field_release:IM.BaseDefine.UserInfo.user_nick_name)
  return user_nick_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UserInfo::set_allocated_user_nick_name(std::string* user_nick_name) {
  if (user_nick_name != nullptr) {
    
  } else {
    
  }
  user_nick_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_nick_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.UserInfo.user_nick_name)
}

// string avatar_url = 4;
inline void UserInfo::clear_avatar_url() {
  avatar_url_.ClearToEmpty();
}
inline const std::string& UserInfo::avatar_url() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserInfo.avatar_url)
  return _internal_avatar_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfo::set_avatar_url(ArgT0&& arg0, ArgT... args) {
 
 avatar_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserInfo.avatar_url)
}
inline std::string* UserInfo::mutable_avatar_url() {
  std::string* _s = _internal_mutable_avatar_url();
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.UserInfo.avatar_url)
  return _s;
}
inline const std::string& UserInfo::_internal_avatar_url() const {
  return avatar_url_.Get();
}
inline void UserInfo::_internal_set_avatar_url(const std::string& value) {
  
  avatar_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UserInfo::_internal_mutable_avatar_url() {
  
  return avatar_url_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UserInfo::release_avatar_url() {
  // @@protoc_insertion_point(field_release:IM.BaseDefine.UserInfo.avatar_url)
  return avatar_url_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UserInfo::set_allocated_avatar_url(std::string* avatar_url) {
  if (avatar_url != nullptr) {
    
  } else {
    
  }
  avatar_url_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), avatar_url,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.UserInfo.avatar_url)
}

// uint32 department_id = 5;
inline void UserInfo::clear_department_id() {
  department_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UserInfo::_internal_department_id() const {
  return department_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UserInfo::department_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserInfo.department_id)
  return _internal_department_id();
}
inline void UserInfo::_internal_set_department_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  department_id_ = value;
}
inline void UserInfo::set_department_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_department_id(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserInfo.department_id)
}

// string email = 6;
inline void UserInfo::clear_email() {
  email_.ClearToEmpty();
}
inline const std::string& UserInfo::email() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserInfo.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfo::set_email(ArgT0&& arg0, ArgT... args) {
 
 email_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserInfo.email)
}
inline std::string* UserInfo::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.UserInfo.email)
  return _s;
}
inline const std::string& UserInfo::_internal_email() const {
  return email_.Get();
}
inline void UserInfo::_internal_set_email(const std::string& value) {
  
  email_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UserInfo::_internal_mutable_email() {
  
  return email_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UserInfo::release_email() {
  // @@protoc_insertion_point(field_release:IM.BaseDefine.UserInfo.email)
  return email_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UserInfo::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    
  } else {
    
  }
  email_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), email,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.UserInfo.email)
}

// string user_real_name = 7;
inline void UserInfo::clear_user_real_name() {
  user_real_name_.ClearToEmpty();
}
inline const std::string& UserInfo::user_real_name() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserInfo.user_real_name)
  return _internal_user_real_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfo::set_user_real_name(ArgT0&& arg0, ArgT... args) {
 
 user_real_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserInfo.user_real_name)
}
inline std::string* UserInfo::mutable_user_real_name() {
  std::string* _s = _internal_mutable_user_real_name();
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.UserInfo.user_real_name)
  return _s;
}
inline const std::string& UserInfo::_internal_user_real_name() const {
  return user_real_name_.Get();
}
inline void UserInfo::_internal_set_user_real_name(const std::string& value) {
  
  user_real_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UserInfo::_internal_mutable_user_real_name() {
  
  return user_real_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UserInfo::release_user_real_name() {
  // @@protoc_insertion_point(field_release:IM.BaseDefine.UserInfo.user_real_name)
  return user_real_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UserInfo::set_allocated_user_real_name(std::string* user_real_name) {
  if (user_real_name != nullptr) {
    
  } else {
    
  }
  user_real_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_real_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.UserInfo.user_real_name)
}

// string user_tel = 8;
inline void UserInfo::clear_user_tel() {
  user_tel_.ClearToEmpty();
}
inline const std::string& UserInfo::user_tel() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserInfo.user_tel)
  return _internal_user_tel();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfo::set_user_tel(ArgT0&& arg0, ArgT... args) {
 
 user_tel_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserInfo.user_tel)
}
inline std::string* UserInfo::mutable_user_tel() {
  std::string* _s = _internal_mutable_user_tel();
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.UserInfo.user_tel)
  return _s;
}
inline const std::string& UserInfo::_internal_user_tel() const {
  return user_tel_.Get();
}
inline void UserInfo::_internal_set_user_tel(const std::string& value) {
  
  user_tel_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UserInfo::_internal_mutable_user_tel() {
  
  return user_tel_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UserInfo::release_user_tel() {
  // @@protoc_insertion_point(field_release:IM.BaseDefine.UserInfo.user_tel)
  return user_tel_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UserInfo::set_allocated_user_tel(std::string* user_tel) {
  if (user_tel != nullptr) {
    
  } else {
    
  }
  user_tel_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_tel,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.UserInfo.user_tel)
}

// string user_domain = 9;
inline void UserInfo::clear_user_domain() {
  user_domain_.ClearToEmpty();
}
inline const std::string& UserInfo::user_domain() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserInfo.user_domain)
  return _internal_user_domain();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfo::set_user_domain(ArgT0&& arg0, ArgT... args) {
 
 user_domain_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserInfo.user_domain)
}
inline std::string* UserInfo::mutable_user_domain() {
  std::string* _s = _internal_mutable_user_domain();
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.UserInfo.user_domain)
  return _s;
}
inline const std::string& UserInfo::_internal_user_domain() const {
  return user_domain_.Get();
}
inline void UserInfo::_internal_set_user_domain(const std::string& value) {
  
  user_domain_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UserInfo::_internal_mutable_user_domain() {
  
  return user_domain_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UserInfo::release_user_domain() {
  // @@protoc_insertion_point(field_release:IM.BaseDefine.UserInfo.user_domain)
  return user_domain_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UserInfo::set_allocated_user_domain(std::string* user_domain) {
  if (user_domain != nullptr) {
    
  } else {
    
  }
  user_domain_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_domain,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.UserInfo.user_domain)
}

// uint32 status = 10;
inline void UserInfo::clear_status() {
  status_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UserInfo::_internal_status() const {
  return status_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UserInfo::status() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserInfo.status)
  return _internal_status();
}
inline void UserInfo::_internal_set_status(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  status_ = value;
}
inline void UserInfo::set_status(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserInfo.status)
}

// string sign_info = 11;
inline void UserInfo::clear_sign_info() {
  sign_info_.ClearToEmpty();
}
inline const std::string& UserInfo::sign_info() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserInfo.sign_info)
  return _internal_sign_info();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfo::set_sign_info(ArgT0&& arg0, ArgT... args) {
 
 sign_info_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserInfo.sign_info)
}
inline std::string* UserInfo::mutable_sign_info() {
  std::string* _s = _internal_mutable_sign_info();
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.UserInfo.sign_info)
  return _s;
}
inline const std::string& UserInfo::_internal_sign_info() const {
  return sign_info_.Get();
}
inline void UserInfo::_internal_set_sign_info(const std::string& value) {
  
  sign_info_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UserInfo::_internal_mutable_sign_info() {
  
  return sign_info_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UserInfo::release_sign_info() {
  // @@protoc_insertion_point(field_release:IM.BaseDefine.UserInfo.sign_info)
  return sign_info_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UserInfo::set_allocated_sign_info(std::string* sign_info) {
  if (sign_info != nullptr) {
    
  } else {
    
  }
  sign_info_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sign_info,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.UserInfo.sign_info)
}

// -------------------------------------------------------------------

// ContactSessionInfo

// uint32 session_id = 1;
inline void ContactSessionInfo::clear_session_id() {
  session_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ContactSessionInfo::_internal_session_id() const {
  return session_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ContactSessionInfo::session_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ContactSessionInfo.session_id)
  return _internal_session_id();
}
inline void ContactSessionInfo::_internal_set_session_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  session_id_ = value;
}
inline void ContactSessionInfo::set_session_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ContactSessionInfo.session_id)
}

// .IM.BaseDefine.SessionType session_type = 2;
inline void ContactSessionInfo::clear_session_type() {
  session_type_ = 0;
}
inline ::IM::BaseDefine::SessionType ContactSessionInfo::_internal_session_type() const {
  return static_cast< ::IM::BaseDefine::SessionType >(session_type_);
}
inline ::IM::BaseDefine::SessionType ContactSessionInfo::session_type() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ContactSessionInfo.session_type)
  return _internal_session_type();
}
inline void ContactSessionInfo::_internal_set_session_type(::IM::BaseDefine::SessionType value) {
  
  session_type_ = value;
}
inline void ContactSessionInfo::set_session_type(::IM::BaseDefine::SessionType value) {
  _internal_set_session_type(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ContactSessionInfo.session_type)
}

// .IM.BaseDefine.SessionStatusType session_status = 3;
inline void ContactSessionInfo::clear_session_status() {
  session_status_ = 0;
}
inline ::IM::BaseDefine::SessionStatusType ContactSessionInfo::_internal_session_status() const {
  return static_cast< ::IM::BaseDefine::SessionStatusType >(session_status_);
}
inline ::IM::BaseDefine::SessionStatusType ContactSessionInfo::session_status() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ContactSessionInfo.session_status)
  return _internal_session_status();
}
inline void ContactSessionInfo::_internal_set_session_status(::IM::BaseDefine::SessionStatusType value) {
  
  session_status_ = value;
}
inline void ContactSessionInfo::set_session_status(::IM::BaseDefine::SessionStatusType value) {
  _internal_set_session_status(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ContactSessionInfo.session_status)
}

// uint32 updated_time = 4;
inline void ContactSessionInfo::clear_updated_time() {
  updated_time_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ContactSessionInfo::_internal_updated_time() const {
  return updated_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ContactSessionInfo::updated_time() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ContactSessionInfo.updated_time)
  return _internal_updated_time();
}
inline void ContactSessionInfo::_internal_set_updated_time(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  updated_time_ = value;
}
inline void ContactSessionInfo::set_updated_time(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_updated_time(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ContactSessionInfo.updated_time)
}

// uint32 latest_msg_id = 5;
inline void ContactSessionInfo::clear_latest_msg_id() {
  latest_msg_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ContactSessionInfo::_internal_latest_msg_id() const {
  return latest_msg_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ContactSessionInfo::latest_msg_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ContactSessionInfo.latest_msg_id)
  return _internal_latest_msg_id();
}
inline void ContactSessionInfo::_internal_set_latest_msg_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  latest_msg_id_ = value;
}
inline void ContactSessionInfo::set_latest_msg_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_latest_msg_id(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ContactSessionInfo.latest_msg_id)
}

// bytes latest_msg_data = 6;
inline void ContactSessionInfo::clear_latest_msg_data() {
  latest_msg_data_.ClearToEmpty();
}
inline const std::string& ContactSessionInfo::latest_msg_data() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ContactSessionInfo.latest_msg_data)
  return _internal_latest_msg_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContactSessionInfo::set_latest_msg_data(ArgT0&& arg0, ArgT... args) {
 
 latest_msg_data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ContactSessionInfo.latest_msg_data)
}
inline std::string* ContactSessionInfo::mutable_latest_msg_data() {
  std::string* _s = _internal_mutable_latest_msg_data();
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.ContactSessionInfo.latest_msg_data)
  return _s;
}
inline const std::string& ContactSessionInfo::_internal_latest_msg_data() const {
  return latest_msg_data_.Get();
}
inline void ContactSessionInfo::_internal_set_latest_msg_data(const std::string& value) {
  
  latest_msg_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ContactSessionInfo::_internal_mutable_latest_msg_data() {
  
  return latest_msg_data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ContactSessionInfo::release_latest_msg_data() {
  // @@protoc_insertion_point(field_release:IM.BaseDefine.ContactSessionInfo.latest_msg_data)
  return latest_msg_data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ContactSessionInfo::set_allocated_latest_msg_data(std::string* latest_msg_data) {
  if (latest_msg_data != nullptr) {
    
  } else {
    
  }
  latest_msg_data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), latest_msg_data,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.ContactSessionInfo.latest_msg_data)
}

// .IM.BaseDefine.MsgType latest_msg_type = 7;
inline void ContactSessionInfo::clear_latest_msg_type() {
  latest_msg_type_ = 0;
}
inline ::IM::BaseDefine::MsgType ContactSessionInfo::_internal_latest_msg_type() const {
  return static_cast< ::IM::BaseDefine::MsgType >(latest_msg_type_);
}
inline ::IM::BaseDefine::MsgType ContactSessionInfo::latest_msg_type() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ContactSessionInfo.latest_msg_type)
  return _internal_latest_msg_type();
}
inline void ContactSessionInfo::_internal_set_latest_msg_type(::IM::BaseDefine::MsgType value) {
  
  latest_msg_type_ = value;
}
inline void ContactSessionInfo::set_latest_msg_type(::IM::BaseDefine::MsgType value) {
  _internal_set_latest_msg_type(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ContactSessionInfo.latest_msg_type)
}

// uint32 latest_msg_from_user_id = 8;
inline void ContactSessionInfo::clear_latest_msg_from_user_id() {
  latest_msg_from_user_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ContactSessionInfo::_internal_latest_msg_from_user_id() const {
  return latest_msg_from_user_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ContactSessionInfo::latest_msg_from_user_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ContactSessionInfo.latest_msg_from_user_id)
  return _internal_latest_msg_from_user_id();
}
inline void ContactSessionInfo::_internal_set_latest_msg_from_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  latest_msg_from_user_id_ = value;
}
inline void ContactSessionInfo::set_latest_msg_from_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_latest_msg_from_user_id(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ContactSessionInfo.latest_msg_from_user_id)
}

// -------------------------------------------------------------------

// UserStat

// uint32 user_id = 1;
inline void UserStat::clear_user_id() {
  user_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UserStat::_internal_user_id() const {
  return user_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UserStat::user_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserStat.user_id)
  return _internal_user_id();
}
inline void UserStat::_internal_set_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  user_id_ = value;
}
inline void UserStat::set_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserStat.user_id)
}

// .IM.BaseDefine.UserStatType status = 2;
inline void UserStat::clear_status() {
  status_ = 0;
}
inline ::IM::BaseDefine::UserStatType UserStat::_internal_status() const {
  return static_cast< ::IM::BaseDefine::UserStatType >(status_);
}
inline ::IM::BaseDefine::UserStatType UserStat::status() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserStat.status)
  return _internal_status();
}
inline void UserStat::_internal_set_status(::IM::BaseDefine::UserStatType value) {
  
  status_ = value;
}
inline void UserStat::set_status(::IM::BaseDefine::UserStatType value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserStat.status)
}

// -------------------------------------------------------------------

// ServerUserStat

// uint32 user_id = 1;
inline void ServerUserStat::clear_user_id() {
  user_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ServerUserStat::_internal_user_id() const {
  return user_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ServerUserStat::user_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ServerUserStat.user_id)
  return _internal_user_id();
}
inline void ServerUserStat::_internal_set_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  user_id_ = value;
}
inline void ServerUserStat::set_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ServerUserStat.user_id)
}

// .IM.BaseDefine.UserStatType status = 2;
inline void ServerUserStat::clear_status() {
  status_ = 0;
}
inline ::IM::BaseDefine::UserStatType ServerUserStat::_internal_status() const {
  return static_cast< ::IM::BaseDefine::UserStatType >(status_);
}
inline ::IM::BaseDefine::UserStatType ServerUserStat::status() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ServerUserStat.status)
  return _internal_status();
}
inline void ServerUserStat::_internal_set_status(::IM::BaseDefine::UserStatType value) {
  
  status_ = value;
}
inline void ServerUserStat::set_status(::IM::BaseDefine::UserStatType value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ServerUserStat.status)
}

// .IM.BaseDefine.ClientType client_type = 3;
inline void ServerUserStat::clear_client_type() {
  client_type_ = 0;
}
inline ::IM::BaseDefine::ClientType ServerUserStat::_internal_client_type() const {
  return static_cast< ::IM::BaseDefine::ClientType >(client_type_);
}
inline ::IM::BaseDefine::ClientType ServerUserStat::client_type() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ServerUserStat.client_type)
  return _internal_client_type();
}
inline void ServerUserStat::_internal_set_client_type(::IM::BaseDefine::ClientType value) {
  
  client_type_ = value;
}
inline void ServerUserStat::set_client_type(::IM::BaseDefine::ClientType value) {
  _internal_set_client_type(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ServerUserStat.client_type)
}

// -------------------------------------------------------------------

// UnreadInfo

// uint32 session_id = 1;
inline void UnreadInfo::clear_session_id() {
  session_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UnreadInfo::_internal_session_id() const {
  return session_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UnreadInfo::session_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UnreadInfo.session_id)
  return _internal_session_id();
}
inline void UnreadInfo::_internal_set_session_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  session_id_ = value;
}
inline void UnreadInfo::set_session_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UnreadInfo.session_id)
}

// .IM.BaseDefine.SessionType session_type = 2;
inline void UnreadInfo::clear_session_type() {
  session_type_ = 0;
}
inline ::IM::BaseDefine::SessionType UnreadInfo::_internal_session_type() const {
  return static_cast< ::IM::BaseDefine::SessionType >(session_type_);
}
inline ::IM::BaseDefine::SessionType UnreadInfo::session_type() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UnreadInfo.session_type)
  return _internal_session_type();
}
inline void UnreadInfo::_internal_set_session_type(::IM::BaseDefine::SessionType value) {
  
  session_type_ = value;
}
inline void UnreadInfo::set_session_type(::IM::BaseDefine::SessionType value) {
  _internal_set_session_type(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UnreadInfo.session_type)
}

// uint32 unread_cnt = 3;
inline void UnreadInfo::clear_unread_cnt() {
  unread_cnt_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UnreadInfo::_internal_unread_cnt() const {
  return unread_cnt_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UnreadInfo::unread_cnt() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UnreadInfo.unread_cnt)
  return _internal_unread_cnt();
}
inline void UnreadInfo::_internal_set_unread_cnt(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  unread_cnt_ = value;
}
inline void UnreadInfo::set_unread_cnt(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_unread_cnt(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UnreadInfo.unread_cnt)
}

// uint32 latest_msg_id = 4;
inline void UnreadInfo::clear_latest_msg_id() {
  latest_msg_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UnreadInfo::_internal_latest_msg_id() const {
  return latest_msg_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UnreadInfo::latest_msg_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UnreadInfo.latest_msg_id)
  return _internal_latest_msg_id();
}
inline void UnreadInfo::_internal_set_latest_msg_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  latest_msg_id_ = value;
}
inline void UnreadInfo::set_latest_msg_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_latest_msg_id(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UnreadInfo.latest_msg_id)
}

// bytes latest_msg_data = 5;
inline void UnreadInfo::clear_latest_msg_data() {
  latest_msg_data_.ClearToEmpty();
}
inline const std::string& UnreadInfo::latest_msg_data() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UnreadInfo.latest_msg_data)
  return _internal_latest_msg_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UnreadInfo::set_latest_msg_data(ArgT0&& arg0, ArgT... args) {
 
 latest_msg_data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UnreadInfo.latest_msg_data)
}
inline std::string* UnreadInfo::mutable_latest_msg_data() {
  std::string* _s = _internal_mutable_latest_msg_data();
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.UnreadInfo.latest_msg_data)
  return _s;
}
inline const std::string& UnreadInfo::_internal_latest_msg_data() const {
  return latest_msg_data_.Get();
}
inline void UnreadInfo::_internal_set_latest_msg_data(const std::string& value) {
  
  latest_msg_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UnreadInfo::_internal_mutable_latest_msg_data() {
  
  return latest_msg_data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UnreadInfo::release_latest_msg_data() {
  // @@protoc_insertion_point(field_release:IM.BaseDefine.UnreadInfo.latest_msg_data)
  return latest_msg_data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UnreadInfo::set_allocated_latest_msg_data(std::string* latest_msg_data) {
  if (latest_msg_data != nullptr) {
    
  } else {
    
  }
  latest_msg_data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), latest_msg_data,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.UnreadInfo.latest_msg_data)
}

// .IM.BaseDefine.MsgType latest_msg_type = 6;
inline void UnreadInfo::clear_latest_msg_type() {
  latest_msg_type_ = 0;
}
inline ::IM::BaseDefine::MsgType UnreadInfo::_internal_latest_msg_type() const {
  return static_cast< ::IM::BaseDefine::MsgType >(latest_msg_type_);
}
inline ::IM::BaseDefine::MsgType UnreadInfo::latest_msg_type() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UnreadInfo.latest_msg_type)
  return _internal_latest_msg_type();
}
inline void UnreadInfo::_internal_set_latest_msg_type(::IM::BaseDefine::MsgType value) {
  
  latest_msg_type_ = value;
}
inline void UnreadInfo::set_latest_msg_type(::IM::BaseDefine::MsgType value) {
  _internal_set_latest_msg_type(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UnreadInfo.latest_msg_type)
}

// uint32 latest_msg_from_user_id = 7;
inline void UnreadInfo::clear_latest_msg_from_user_id() {
  latest_msg_from_user_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UnreadInfo::_internal_latest_msg_from_user_id() const {
  return latest_msg_from_user_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UnreadInfo::latest_msg_from_user_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UnreadInfo.latest_msg_from_user_id)
  return _internal_latest_msg_from_user_id();
}
inline void UnreadInfo::_internal_set_latest_msg_from_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  latest_msg_from_user_id_ = value;
}
inline void UnreadInfo::set_latest_msg_from_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_latest_msg_from_user_id(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UnreadInfo.latest_msg_from_user_id)
}

// -------------------------------------------------------------------

// MsgInfo

// uint32 msg_id = 1;
inline void MsgInfo::clear_msg_id() {
  msg_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MsgInfo::_internal_msg_id() const {
  return msg_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MsgInfo::msg_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.MsgInfo.msg_id)
  return _internal_msg_id();
}
inline void MsgInfo::_internal_set_msg_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  msg_id_ = value;
}
inline void MsgInfo::set_msg_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_msg_id(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.MsgInfo.msg_id)
}

// uint32 from_session_id = 2;
inline void MsgInfo::clear_from_session_id() {
  from_session_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MsgInfo::_internal_from_session_id() const {
  return from_session_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MsgInfo::from_session_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.MsgInfo.from_session_id)
  return _internal_from_session_id();
}
inline void MsgInfo::_internal_set_from_session_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  from_session_id_ = value;
}
inline void MsgInfo::set_from_session_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_from_session_id(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.MsgInfo.from_session_id)
}

// uint32 create_time = 3;
inline void MsgInfo::clear_create_time() {
  create_time_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MsgInfo::_internal_create_time() const {
  return create_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MsgInfo::create_time() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.MsgInfo.create_time)
  return _internal_create_time();
}
inline void MsgInfo::_internal_set_create_time(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  create_time_ = value;
}
inline void MsgInfo::set_create_time(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_create_time(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.MsgInfo.create_time)
}

// .IM.BaseDefine.MsgType msg_type = 4;
inline void MsgInfo::clear_msg_type() {
  msg_type_ = 0;
}
inline ::IM::BaseDefine::MsgType MsgInfo::_internal_msg_type() const {
  return static_cast< ::IM::BaseDefine::MsgType >(msg_type_);
}
inline ::IM::BaseDefine::MsgType MsgInfo::msg_type() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.MsgInfo.msg_type)
  return _internal_msg_type();
}
inline void MsgInfo::_internal_set_msg_type(::IM::BaseDefine::MsgType value) {
  
  msg_type_ = value;
}
inline void MsgInfo::set_msg_type(::IM::BaseDefine::MsgType value) {
  _internal_set_msg_type(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.MsgInfo.msg_type)
}

// bytes msg_data = 5;
inline void MsgInfo::clear_msg_data() {
  msg_data_.ClearToEmpty();
}
inline const std::string& MsgInfo::msg_data() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.MsgInfo.msg_data)
  return _internal_msg_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MsgInfo::set_msg_data(ArgT0&& arg0, ArgT... args) {
 
 msg_data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IM.BaseDefine.MsgInfo.msg_data)
}
inline std::string* MsgInfo::mutable_msg_data() {
  std::string* _s = _internal_mutable_msg_data();
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.MsgInfo.msg_data)
  return _s;
}
inline const std::string& MsgInfo::_internal_msg_data() const {
  return msg_data_.Get();
}
inline void MsgInfo::_internal_set_msg_data(const std::string& value) {
  
  msg_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MsgInfo::_internal_mutable_msg_data() {
  
  return msg_data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MsgInfo::release_msg_data() {
  // @@protoc_insertion_point(field_release:IM.BaseDefine.MsgInfo.msg_data)
  return msg_data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MsgInfo::set_allocated_msg_data(std::string* msg_data) {
  if (msg_data != nullptr) {
    
  } else {
    
  }
  msg_data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg_data,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.MsgInfo.msg_data)
}

// -------------------------------------------------------------------

// GroupVersionInfo

// uint32 group_id = 1;
inline void GroupVersionInfo::clear_group_id() {
  group_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GroupVersionInfo::_internal_group_id() const {
  return group_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GroupVersionInfo::group_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.GroupVersionInfo.group_id)
  return _internal_group_id();
}
inline void GroupVersionInfo::_internal_set_group_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  group_id_ = value;
}
inline void GroupVersionInfo::set_group_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_group_id(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.GroupVersionInfo.group_id)
}

// uint32 version = 2;
inline void GroupVersionInfo::clear_version() {
  version_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GroupVersionInfo::_internal_version() const {
  return version_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GroupVersionInfo::version() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.GroupVersionInfo.version)
  return _internal_version();
}
inline void GroupVersionInfo::_internal_set_version(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  version_ = value;
}
inline void GroupVersionInfo::set_version(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.GroupVersionInfo.version)
}

// -------------------------------------------------------------------

// GroupInfo

// uint32 group_id = 1;
inline void GroupInfo::clear_group_id() {
  group_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GroupInfo::_internal_group_id() const {
  return group_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GroupInfo::group_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.GroupInfo.group_id)
  return _internal_group_id();
}
inline void GroupInfo::_internal_set_group_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  group_id_ = value;
}
inline void GroupInfo::set_group_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_group_id(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.GroupInfo.group_id)
}

// uint32 version = 2;
inline void GroupInfo::clear_version() {
  version_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GroupInfo::_internal_version() const {
  return version_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GroupInfo::version() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.GroupInfo.version)
  return _internal_version();
}
inline void GroupInfo::_internal_set_version(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  version_ = value;
}
inline void GroupInfo::set_version(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.GroupInfo.version)
}

// string group_name = 3;
inline void GroupInfo::clear_group_name() {
  group_name_.ClearToEmpty();
}
inline const std::string& GroupInfo::group_name() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.GroupInfo.group_name)
  return _internal_group_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GroupInfo::set_group_name(ArgT0&& arg0, ArgT... args) {
 
 group_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IM.BaseDefine.GroupInfo.group_name)
}
inline std::string* GroupInfo::mutable_group_name() {
  std::string* _s = _internal_mutable_group_name();
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.GroupInfo.group_name)
  return _s;
}
inline const std::string& GroupInfo::_internal_group_name() const {
  return group_name_.Get();
}
inline void GroupInfo::_internal_set_group_name(const std::string& value) {
  
  group_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GroupInfo::_internal_mutable_group_name() {
  
  return group_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GroupInfo::release_group_name() {
  // @@protoc_insertion_point(field_release:IM.BaseDefine.GroupInfo.group_name)
  return group_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GroupInfo::set_allocated_group_name(std::string* group_name) {
  if (group_name != nullptr) {
    
  } else {
    
  }
  group_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), group_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.GroupInfo.group_name)
}

// string group_avatar = 4;
inline void GroupInfo::clear_group_avatar() {
  group_avatar_.ClearToEmpty();
}
inline const std::string& GroupInfo::group_avatar() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.GroupInfo.group_avatar)
  return _internal_group_avatar();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GroupInfo::set_group_avatar(ArgT0&& arg0, ArgT... args) {
 
 group_avatar_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IM.BaseDefine.GroupInfo.group_avatar)
}
inline std::string* GroupInfo::mutable_group_avatar() {
  std::string* _s = _internal_mutable_group_avatar();
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.GroupInfo.group_avatar)
  return _s;
}
inline const std::string& GroupInfo::_internal_group_avatar() const {
  return group_avatar_.Get();
}
inline void GroupInfo::_internal_set_group_avatar(const std::string& value) {
  
  group_avatar_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GroupInfo::_internal_mutable_group_avatar() {
  
  return group_avatar_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GroupInfo::release_group_avatar() {
  // @@protoc_insertion_point(field_release:IM.BaseDefine.GroupInfo.group_avatar)
  return group_avatar_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GroupInfo::set_allocated_group_avatar(std::string* group_avatar) {
  if (group_avatar != nullptr) {
    
  } else {
    
  }
  group_avatar_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), group_avatar,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.GroupInfo.group_avatar)
}

// uint32 group_creator_id = 5;
inline void GroupInfo::clear_group_creator_id() {
  group_creator_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GroupInfo::_internal_group_creator_id() const {
  return group_creator_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GroupInfo::group_creator_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.GroupInfo.group_creator_id)
  return _internal_group_creator_id();
}
inline void GroupInfo::_internal_set_group_creator_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  group_creator_id_ = value;
}
inline void GroupInfo::set_group_creator_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_group_creator_id(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.GroupInfo.group_creator_id)
}

// .IM.BaseDefine.GroupType group_type = 6;
inline void GroupInfo::clear_group_type() {
  group_type_ = 0;
}
inline ::IM::BaseDefine::GroupType GroupInfo::_internal_group_type() const {
  return static_cast< ::IM::BaseDefine::GroupType >(group_type_);
}
inline ::IM::BaseDefine::GroupType GroupInfo::group_type() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.GroupInfo.group_type)
  return _internal_group_type();
}
inline void GroupInfo::_internal_set_group_type(::IM::BaseDefine::GroupType value) {
  
  group_type_ = value;
}
inline void GroupInfo::set_group_type(::IM::BaseDefine::GroupType value) {
  _internal_set_group_type(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.GroupInfo.group_type)
}

// uint32 shield_status = 7;
inline void GroupInfo::clear_shield_status() {
  shield_status_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GroupInfo::_internal_shield_status() const {
  return shield_status_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GroupInfo::shield_status() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.GroupInfo.shield_status)
  return _internal_shield_status();
}
inline void GroupInfo::_internal_set_shield_status(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  shield_status_ = value;
}
inline void GroupInfo::set_shield_status(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_shield_status(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.GroupInfo.shield_status)
}

// repeated uint32 group_member_list = 8;
inline int GroupInfo::_internal_group_member_list_size() const {
  return group_member_list_.size();
}
inline int GroupInfo::group_member_list_size() const {
  return _internal_group_member_list_size();
}
inline void GroupInfo::clear_group_member_list() {
  group_member_list_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GroupInfo::_internal_group_member_list(int index) const {
  return group_member_list_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GroupInfo::group_member_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.GroupInfo.group_member_list)
  return _internal_group_member_list(index);
}
inline void GroupInfo::set_group_member_list(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value) {
  group_member_list_.Set(index, value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.GroupInfo.group_member_list)
}
inline void GroupInfo::_internal_add_group_member_list(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  group_member_list_.Add(value);
}
inline void GroupInfo::add_group_member_list(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_add_group_member_list(value);
  // @@protoc_insertion_point(field_add:IM.BaseDefine.GroupInfo.group_member_list)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
GroupInfo::_internal_group_member_list() const {
  return group_member_list_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
GroupInfo::group_member_list() const {
  // @@protoc_insertion_point(field_list:IM.BaseDefine.GroupInfo.group_member_list)
  return _internal_group_member_list();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
GroupInfo::_internal_mutable_group_member_list() {
  return &group_member_list_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
GroupInfo::mutable_group_member_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.BaseDefine.GroupInfo.group_member_list)
  return _internal_mutable_group_member_list();
}

// -------------------------------------------------------------------

// UserTokenInfo

// uint32 user_id = 1;
inline void UserTokenInfo::clear_user_id() {
  user_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UserTokenInfo::_internal_user_id() const {
  return user_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UserTokenInfo::user_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserTokenInfo.user_id)
  return _internal_user_id();
}
inline void UserTokenInfo::_internal_set_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  user_id_ = value;
}
inline void UserTokenInfo::set_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserTokenInfo.user_id)
}

// .IM.BaseDefine.ClientType user_type = 2;
inline void UserTokenInfo::clear_user_type() {
  user_type_ = 0;
}
inline ::IM::BaseDefine::ClientType UserTokenInfo::_internal_user_type() const {
  return static_cast< ::IM::BaseDefine::ClientType >(user_type_);
}
inline ::IM::BaseDefine::ClientType UserTokenInfo::user_type() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserTokenInfo.user_type)
  return _internal_user_type();
}
inline void UserTokenInfo::_internal_set_user_type(::IM::BaseDefine::ClientType value) {
  
  user_type_ = value;
}
inline void UserTokenInfo::set_user_type(::IM::BaseDefine::ClientType value) {
  _internal_set_user_type(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserTokenInfo.user_type)
}

// string token = 3;
inline void UserTokenInfo::clear_token() {
  token_.ClearToEmpty();
}
inline const std::string& UserTokenInfo::token() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserTokenInfo.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserTokenInfo::set_token(ArgT0&& arg0, ArgT... args) {
 
 token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserTokenInfo.token)
}
inline std::string* UserTokenInfo::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.UserTokenInfo.token)
  return _s;
}
inline const std::string& UserTokenInfo::_internal_token() const {
  return token_.Get();
}
inline void UserTokenInfo::_internal_set_token(const std::string& value) {
  
  token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UserTokenInfo::_internal_mutable_token() {
  
  return token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UserTokenInfo::release_token() {
  // @@protoc_insertion_point(field_release:IM.BaseDefine.UserTokenInfo.token)
  return token_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UserTokenInfo::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.UserTokenInfo.token)
}

// uint32 push_count = 4;
inline void UserTokenInfo::clear_push_count() {
  push_count_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UserTokenInfo::_internal_push_count() const {
  return push_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UserTokenInfo::push_count() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserTokenInfo.push_count)
  return _internal_push_count();
}
inline void UserTokenInfo::_internal_set_push_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  push_count_ = value;
}
inline void UserTokenInfo::set_push_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_push_count(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserTokenInfo.push_count)
}

// uint32 push_type = 5;
inline void UserTokenInfo::clear_push_type() {
  push_type_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UserTokenInfo::_internal_push_type() const {
  return push_type_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UserTokenInfo::push_type() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserTokenInfo.push_type)
  return _internal_push_type();
}
inline void UserTokenInfo::_internal_set_push_type(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  push_type_ = value;
}
inline void UserTokenInfo::set_push_type(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_push_type(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserTokenInfo.push_type)
}

// -------------------------------------------------------------------

// PushResult

// string user_token = 1;
inline void PushResult::clear_user_token() {
  user_token_.ClearToEmpty();
}
inline const std::string& PushResult::user_token() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.PushResult.user_token)
  return _internal_user_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PushResult::set_user_token(ArgT0&& arg0, ArgT... args) {
 
 user_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IM.BaseDefine.PushResult.user_token)
}
inline std::string* PushResult::mutable_user_token() {
  std::string* _s = _internal_mutable_user_token();
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.PushResult.user_token)
  return _s;
}
inline const std::string& PushResult::_internal_user_token() const {
  return user_token_.Get();
}
inline void PushResult::_internal_set_user_token(const std::string& value) {
  
  user_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PushResult::_internal_mutable_user_token() {
  
  return user_token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PushResult::release_user_token() {
  // @@protoc_insertion_point(field_release:IM.BaseDefine.PushResult.user_token)
  return user_token_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PushResult::set_allocated_user_token(std::string* user_token) {
  if (user_token != nullptr) {
    
  } else {
    
  }
  user_token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_token,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.PushResult.user_token)
}

// uint32 result_code = 2;
inline void PushResult::clear_result_code() {
  result_code_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PushResult::_internal_result_code() const {
  return result_code_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PushResult::result_code() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.PushResult.result_code)
  return _internal_result_code();
}
inline void PushResult::_internal_set_result_code(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  result_code_ = value;
}
inline void PushResult::set_result_code(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_result_code(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.PushResult.result_code)
}

// -------------------------------------------------------------------

// ShieldStatus

// uint32 user_id = 1;
inline void ShieldStatus::clear_user_id() {
  user_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ShieldStatus::_internal_user_id() const {
  return user_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ShieldStatus::user_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ShieldStatus.user_id)
  return _internal_user_id();
}
inline void ShieldStatus::_internal_set_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  user_id_ = value;
}
inline void ShieldStatus::set_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ShieldStatus.user_id)
}

// uint32 group_id = 2;
inline void ShieldStatus::clear_group_id() {
  group_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ShieldStatus::_internal_group_id() const {
  return group_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ShieldStatus::group_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ShieldStatus.group_id)
  return _internal_group_id();
}
inline void ShieldStatus::_internal_set_group_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  group_id_ = value;
}
inline void ShieldStatus::set_group_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_group_id(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ShieldStatus.group_id)
}

// uint32 shield_status = 3;
inline void ShieldStatus::clear_shield_status() {
  shield_status_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ShieldStatus::_internal_shield_status() const {
  return shield_status_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ShieldStatus::shield_status() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ShieldStatus.shield_status)
  return _internal_shield_status();
}
inline void ShieldStatus::_internal_set_shield_status(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  shield_status_ = value;
}
inline void ShieldStatus::set_shield_status(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_shield_status(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ShieldStatus.shield_status)
}

// -------------------------------------------------------------------

// OfflineFileInfo

// uint32 from_user_id = 1;
inline void OfflineFileInfo::clear_from_user_id() {
  from_user_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 OfflineFileInfo::_internal_from_user_id() const {
  return from_user_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 OfflineFileInfo::from_user_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.OfflineFileInfo.from_user_id)
  return _internal_from_user_id();
}
inline void OfflineFileInfo::_internal_set_from_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  from_user_id_ = value;
}
inline void OfflineFileInfo::set_from_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_from_user_id(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.OfflineFileInfo.from_user_id)
}

// string task_id = 2;
inline void OfflineFileInfo::clear_task_id() {
  task_id_.ClearToEmpty();
}
inline const std::string& OfflineFileInfo::task_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.OfflineFileInfo.task_id)
  return _internal_task_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OfflineFileInfo::set_task_id(ArgT0&& arg0, ArgT... args) {
 
 task_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IM.BaseDefine.OfflineFileInfo.task_id)
}
inline std::string* OfflineFileInfo::mutable_task_id() {
  std::string* _s = _internal_mutable_task_id();
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.OfflineFileInfo.task_id)
  return _s;
}
inline const std::string& OfflineFileInfo::_internal_task_id() const {
  return task_id_.Get();
}
inline void OfflineFileInfo::_internal_set_task_id(const std::string& value) {
  
  task_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* OfflineFileInfo::_internal_mutable_task_id() {
  
  return task_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* OfflineFileInfo::release_task_id() {
  // @@protoc_insertion_point(field_release:IM.BaseDefine.OfflineFileInfo.task_id)
  return task_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void OfflineFileInfo::set_allocated_task_id(std::string* task_id) {
  if (task_id != nullptr) {
    
  } else {
    
  }
  task_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), task_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.OfflineFileInfo.task_id)
}

// string file_name = 3;
inline void OfflineFileInfo::clear_file_name() {
  file_name_.ClearToEmpty();
}
inline const std::string& OfflineFileInfo::file_name() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.OfflineFileInfo.file_name)
  return _internal_file_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OfflineFileInfo::set_file_name(ArgT0&& arg0, ArgT... args) {
 
 file_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IM.BaseDefine.OfflineFileInfo.file_name)
}
inline std::string* OfflineFileInfo::mutable_file_name() {
  std::string* _s = _internal_mutable_file_name();
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.OfflineFileInfo.file_name)
  return _s;
}
inline const std::string& OfflineFileInfo::_internal_file_name() const {
  return file_name_.Get();
}
inline void OfflineFileInfo::_internal_set_file_name(const std::string& value) {
  
  file_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* OfflineFileInfo::_internal_mutable_file_name() {
  
  return file_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* OfflineFileInfo::release_file_name() {
  // @@protoc_insertion_point(field_release:IM.BaseDefine.OfflineFileInfo.file_name)
  return file_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void OfflineFileInfo::set_allocated_file_name(std::string* file_name) {
  if (file_name != nullptr) {
    
  } else {
    
  }
  file_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.OfflineFileInfo.file_name)
}

// uint32 file_size = 4;
inline void OfflineFileInfo::clear_file_size() {
  file_size_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 OfflineFileInfo::_internal_file_size() const {
  return file_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 OfflineFileInfo::file_size() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.OfflineFileInfo.file_size)
  return _internal_file_size();
}
inline void OfflineFileInfo::_internal_set_file_size(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  file_size_ = value;
}
inline void OfflineFileInfo::set_file_size(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_file_size(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.OfflineFileInfo.file_size)
}

// -------------------------------------------------------------------

// DepartInfo

// uint32 dept_id = 1;
inline void DepartInfo::clear_dept_id() {
  dept_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DepartInfo::_internal_dept_id() const {
  return dept_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DepartInfo::dept_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.DepartInfo.dept_id)
  return _internal_dept_id();
}
inline void DepartInfo::_internal_set_dept_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  dept_id_ = value;
}
inline void DepartInfo::set_dept_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_dept_id(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.DepartInfo.dept_id)
}

// uint32 priority = 2;
inline void DepartInfo::clear_priority() {
  priority_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DepartInfo::_internal_priority() const {
  return priority_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DepartInfo::priority() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.DepartInfo.priority)
  return _internal_priority();
}
inline void DepartInfo::_internal_set_priority(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  priority_ = value;
}
inline void DepartInfo::set_priority(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_priority(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.DepartInfo.priority)
}

// string dept_name = 3;
inline void DepartInfo::clear_dept_name() {
  dept_name_.ClearToEmpty();
}
inline const std::string& DepartInfo::dept_name() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.DepartInfo.dept_name)
  return _internal_dept_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DepartInfo::set_dept_name(ArgT0&& arg0, ArgT... args) {
 
 dept_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IM.BaseDefine.DepartInfo.dept_name)
}
inline std::string* DepartInfo::mutable_dept_name() {
  std::string* _s = _internal_mutable_dept_name();
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.DepartInfo.dept_name)
  return _s;
}
inline const std::string& DepartInfo::_internal_dept_name() const {
  return dept_name_.Get();
}
inline void DepartInfo::_internal_set_dept_name(const std::string& value) {
  
  dept_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DepartInfo::_internal_mutable_dept_name() {
  
  return dept_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DepartInfo::release_dept_name() {
  // @@protoc_insertion_point(field_release:IM.BaseDefine.DepartInfo.dept_name)
  return dept_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DepartInfo::set_allocated_dept_name(std::string* dept_name) {
  if (dept_name != nullptr) {
    
  } else {
    
  }
  dept_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), dept_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.DepartInfo.dept_name)
}

// uint32 parent_dept_id = 4;
inline void DepartInfo::clear_parent_dept_id() {
  parent_dept_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DepartInfo::_internal_parent_dept_id() const {
  return parent_dept_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DepartInfo::parent_dept_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.DepartInfo.parent_dept_id)
  return _internal_parent_dept_id();
}
inline void DepartInfo::_internal_set_parent_dept_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  parent_dept_id_ = value;
}
inline void DepartInfo::set_parent_dept_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_parent_dept_id(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.DepartInfo.parent_dept_id)
}

// .IM.BaseDefine.DepartmentStatusType dept_status = 5;
inline void DepartInfo::clear_dept_status() {
  dept_status_ = 0;
}
inline ::IM::BaseDefine::DepartmentStatusType DepartInfo::_internal_dept_status() const {
  return static_cast< ::IM::BaseDefine::DepartmentStatusType >(dept_status_);
}
inline ::IM::BaseDefine::DepartmentStatusType DepartInfo::dept_status() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.DepartInfo.dept_status)
  return _internal_dept_status();
}
inline void DepartInfo::_internal_set_dept_status(::IM::BaseDefine::DepartmentStatusType value) {
  
  dept_status_ = value;
}
inline void DepartInfo::set_dept_status(::IM::BaseDefine::DepartmentStatusType value) {
  _internal_set_dept_status(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.DepartInfo.dept_status)
}

// -------------------------------------------------------------------

// PushShieldStatus

// uint32 user_id = 1;
inline void PushShieldStatus::clear_user_id() {
  user_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PushShieldStatus::_internal_user_id() const {
  return user_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PushShieldStatus::user_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.PushShieldStatus.user_id)
  return _internal_user_id();
}
inline void PushShieldStatus::_internal_set_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  user_id_ = value;
}
inline void PushShieldStatus::set_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.PushShieldStatus.user_id)
}

// uint32 shield_status = 2;
inline void PushShieldStatus::clear_shield_status() {
  shield_status_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PushShieldStatus::_internal_shield_status() const {
  return shield_status_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PushShieldStatus::shield_status() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.PushShieldStatus.shield_status)
  return _internal_shield_status();
}
inline void PushShieldStatus::_internal_set_shield_status(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  shield_status_ = value;
}
inline void PushShieldStatus::set_shield_status(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_shield_status(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.PushShieldStatus.shield_status)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace BaseDefine
}  // namespace IM

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::IM::BaseDefine::ServiceID> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IM::BaseDefine::ServiceID>() {
  return ::IM::BaseDefine::ServiceID_descriptor();
}
template <> struct is_proto_enum< ::IM::BaseDefine::LoginCmdID> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IM::BaseDefine::LoginCmdID>() {
  return ::IM::BaseDefine::LoginCmdID_descriptor();
}
template <> struct is_proto_enum< ::IM::BaseDefine::BuddyListCmdID> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IM::BaseDefine::BuddyListCmdID>() {
  return ::IM::BaseDefine::BuddyListCmdID_descriptor();
}
template <> struct is_proto_enum< ::IM::BaseDefine::MessageCmdID> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IM::BaseDefine::MessageCmdID>() {
  return ::IM::BaseDefine::MessageCmdID_descriptor();
}
template <> struct is_proto_enum< ::IM::BaseDefine::GroupCmdID> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IM::BaseDefine::GroupCmdID>() {
  return ::IM::BaseDefine::GroupCmdID_descriptor();
}
template <> struct is_proto_enum< ::IM::BaseDefine::FileCmdID> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IM::BaseDefine::FileCmdID>() {
  return ::IM::BaseDefine::FileCmdID_descriptor();
}
template <> struct is_proto_enum< ::IM::BaseDefine::SwitchServiceCmdID> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IM::BaseDefine::SwitchServiceCmdID>() {
  return ::IM::BaseDefine::SwitchServiceCmdID_descriptor();
}
template <> struct is_proto_enum< ::IM::BaseDefine::OtherCmdID> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IM::BaseDefine::OtherCmdID>() {
  return ::IM::BaseDefine::OtherCmdID_descriptor();
}
template <> struct is_proto_enum< ::IM::BaseDefine::ResultType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IM::BaseDefine::ResultType>() {
  return ::IM::BaseDefine::ResultType_descriptor();
}
template <> struct is_proto_enum< ::IM::BaseDefine::KickReasonType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IM::BaseDefine::KickReasonType>() {
  return ::IM::BaseDefine::KickReasonType_descriptor();
}
template <> struct is_proto_enum< ::IM::BaseDefine::OnlineListType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IM::BaseDefine::OnlineListType>() {
  return ::IM::BaseDefine::OnlineListType_descriptor();
}
template <> struct is_proto_enum< ::IM::BaseDefine::UserStatType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IM::BaseDefine::UserStatType>() {
  return ::IM::BaseDefine::UserStatType_descriptor();
}
template <> struct is_proto_enum< ::IM::BaseDefine::SessionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IM::BaseDefine::SessionType>() {
  return ::IM::BaseDefine::SessionType_descriptor();
}
template <> struct is_proto_enum< ::IM::BaseDefine::MsgType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IM::BaseDefine::MsgType>() {
  return ::IM::BaseDefine::MsgType_descriptor();
}
template <> struct is_proto_enum< ::IM::BaseDefine::ClientType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IM::BaseDefine::ClientType>() {
  return ::IM::BaseDefine::ClientType_descriptor();
}
template <> struct is_proto_enum< ::IM::BaseDefine::GroupType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IM::BaseDefine::GroupType>() {
  return ::IM::BaseDefine::GroupType_descriptor();
}
template <> struct is_proto_enum< ::IM::BaseDefine::GroupModifyType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IM::BaseDefine::GroupModifyType>() {
  return ::IM::BaseDefine::GroupModifyType_descriptor();
}
template <> struct is_proto_enum< ::IM::BaseDefine::TransferFileType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IM::BaseDefine::TransferFileType>() {
  return ::IM::BaseDefine::TransferFileType_descriptor();
}
template <> struct is_proto_enum< ::IM::BaseDefine::ClientFileState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IM::BaseDefine::ClientFileState>() {
  return ::IM::BaseDefine::ClientFileState_descriptor();
}
template <> struct is_proto_enum< ::IM::BaseDefine::ClientFileRole> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IM::BaseDefine::ClientFileRole>() {
  return ::IM::BaseDefine::ClientFileRole_descriptor();
}
template <> struct is_proto_enum< ::IM::BaseDefine::FileServerError> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IM::BaseDefine::FileServerError>() {
  return ::IM::BaseDefine::FileServerError_descriptor();
}
template <> struct is_proto_enum< ::IM::BaseDefine::SessionStatusType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IM::BaseDefine::SessionStatusType>() {
  return ::IM::BaseDefine::SessionStatusType_descriptor();
}
template <> struct is_proto_enum< ::IM::BaseDefine::DepartmentStatusType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IM::BaseDefine::DepartmentStatusType>() {
  return ::IM::BaseDefine::DepartmentStatusType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_IM_2eBaseDefine_2eproto
