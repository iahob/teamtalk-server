// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: IM.File.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_IM_2eFile_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_IM_2eFile_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3018000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3018001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "IM.BaseDefine.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_IM_2eFile_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_IM_2eFile_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[12]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_IM_2eFile_2eproto;
namespace IM {
namespace File {
class IMFileAddOfflineReq;
struct IMFileAddOfflineReqDefaultTypeInternal;
extern IMFileAddOfflineReqDefaultTypeInternal _IMFileAddOfflineReq_default_instance_;
class IMFileDelOfflineReq;
struct IMFileDelOfflineReqDefaultTypeInternal;
extern IMFileDelOfflineReqDefaultTypeInternal _IMFileDelOfflineReq_default_instance_;
class IMFileHasOfflineReq;
struct IMFileHasOfflineReqDefaultTypeInternal;
extern IMFileHasOfflineReqDefaultTypeInternal _IMFileHasOfflineReq_default_instance_;
class IMFileHasOfflineRsp;
struct IMFileHasOfflineRspDefaultTypeInternal;
extern IMFileHasOfflineRspDefaultTypeInternal _IMFileHasOfflineRsp_default_instance_;
class IMFileLoginReq;
struct IMFileLoginReqDefaultTypeInternal;
extern IMFileLoginReqDefaultTypeInternal _IMFileLoginReq_default_instance_;
class IMFileLoginRsp;
struct IMFileLoginRspDefaultTypeInternal;
extern IMFileLoginRspDefaultTypeInternal _IMFileLoginRsp_default_instance_;
class IMFileNotify;
struct IMFileNotifyDefaultTypeInternal;
extern IMFileNotifyDefaultTypeInternal _IMFileNotify_default_instance_;
class IMFilePullDataReq;
struct IMFilePullDataReqDefaultTypeInternal;
extern IMFilePullDataReqDefaultTypeInternal _IMFilePullDataReq_default_instance_;
class IMFilePullDataRsp;
struct IMFilePullDataRspDefaultTypeInternal;
extern IMFilePullDataRspDefaultTypeInternal _IMFilePullDataRsp_default_instance_;
class IMFileReq;
struct IMFileReqDefaultTypeInternal;
extern IMFileReqDefaultTypeInternal _IMFileReq_default_instance_;
class IMFileRsp;
struct IMFileRspDefaultTypeInternal;
extern IMFileRspDefaultTypeInternal _IMFileRsp_default_instance_;
class IMFileState;
struct IMFileStateDefaultTypeInternal;
extern IMFileStateDefaultTypeInternal _IMFileState_default_instance_;
}  // namespace File
}  // namespace IM
PROTOBUF_NAMESPACE_OPEN
template<> ::IM::File::IMFileAddOfflineReq* Arena::CreateMaybeMessage<::IM::File::IMFileAddOfflineReq>(Arena*);
template<> ::IM::File::IMFileDelOfflineReq* Arena::CreateMaybeMessage<::IM::File::IMFileDelOfflineReq>(Arena*);
template<> ::IM::File::IMFileHasOfflineReq* Arena::CreateMaybeMessage<::IM::File::IMFileHasOfflineReq>(Arena*);
template<> ::IM::File::IMFileHasOfflineRsp* Arena::CreateMaybeMessage<::IM::File::IMFileHasOfflineRsp>(Arena*);
template<> ::IM::File::IMFileLoginReq* Arena::CreateMaybeMessage<::IM::File::IMFileLoginReq>(Arena*);
template<> ::IM::File::IMFileLoginRsp* Arena::CreateMaybeMessage<::IM::File::IMFileLoginRsp>(Arena*);
template<> ::IM::File::IMFileNotify* Arena::CreateMaybeMessage<::IM::File::IMFileNotify>(Arena*);
template<> ::IM::File::IMFilePullDataReq* Arena::CreateMaybeMessage<::IM::File::IMFilePullDataReq>(Arena*);
template<> ::IM::File::IMFilePullDataRsp* Arena::CreateMaybeMessage<::IM::File::IMFilePullDataRsp>(Arena*);
template<> ::IM::File::IMFileReq* Arena::CreateMaybeMessage<::IM::File::IMFileReq>(Arena*);
template<> ::IM::File::IMFileRsp* Arena::CreateMaybeMessage<::IM::File::IMFileRsp>(Arena*);
template<> ::IM::File::IMFileState* Arena::CreateMaybeMessage<::IM::File::IMFileState>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace IM {
namespace File {

// ===================================================================

class IMFileLoginReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IM.File.IMFileLoginReq) */ {
 public:
  inline IMFileLoginReq() : IMFileLoginReq(nullptr) {}
  ~IMFileLoginReq() override;
  explicit constexpr IMFileLoginReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IMFileLoginReq(const IMFileLoginReq& from);
  IMFileLoginReq(IMFileLoginReq&& from) noexcept
    : IMFileLoginReq() {
    *this = ::std::move(from);
  }

  inline IMFileLoginReq& operator=(const IMFileLoginReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline IMFileLoginReq& operator=(IMFileLoginReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IMFileLoginReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const IMFileLoginReq* internal_default_instance() {
    return reinterpret_cast<const IMFileLoginReq*>(
               &_IMFileLoginReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(IMFileLoginReq& a, IMFileLoginReq& b) {
    a.Swap(&b);
  }
  inline void Swap(IMFileLoginReq* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IMFileLoginReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IMFileLoginReq* New() const final {
    return new IMFileLoginReq();
  }

  IMFileLoginReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IMFileLoginReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IMFileLoginReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IMFileLoginReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IMFileLoginReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IM.File.IMFileLoginReq";
  }
  protected:
  explicit IMFileLoginReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskIdFieldNumber = 2,
    kUserIdFieldNumber = 1,
    kFileRoleFieldNumber = 3,
  };
  // string task_id = 2;
  void clear_task_id();
  const std::string& task_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_task_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_task_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_task_id();
  void set_allocated_task_id(std::string* task_id);
  private:
  const std::string& _internal_task_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_task_id(const std::string& value);
  std::string* _internal_mutable_task_id();
  public:

  // uint32 user_id = 1;
  void clear_user_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 user_id() const;
  void set_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_user_id() const;
  void _internal_set_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // .IM.BaseDefine.ClientFileRole file_role = 3;
  void clear_file_role();
  ::IM::BaseDefine::ClientFileRole file_role() const;
  void set_file_role(::IM::BaseDefine::ClientFileRole value);
  private:
  ::IM::BaseDefine::ClientFileRole _internal_file_role() const;
  void _internal_set_file_role(::IM::BaseDefine::ClientFileRole value);
  public:

  // @@protoc_insertion_point(class_scope:IM.File.IMFileLoginReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr task_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 user_id_;
  int file_role_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_IM_2eFile_2eproto;
};
// -------------------------------------------------------------------

class IMFileLoginRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IM.File.IMFileLoginRsp) */ {
 public:
  inline IMFileLoginRsp() : IMFileLoginRsp(nullptr) {}
  ~IMFileLoginRsp() override;
  explicit constexpr IMFileLoginRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IMFileLoginRsp(const IMFileLoginRsp& from);
  IMFileLoginRsp(IMFileLoginRsp&& from) noexcept
    : IMFileLoginRsp() {
    *this = ::std::move(from);
  }

  inline IMFileLoginRsp& operator=(const IMFileLoginRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline IMFileLoginRsp& operator=(IMFileLoginRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IMFileLoginRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const IMFileLoginRsp* internal_default_instance() {
    return reinterpret_cast<const IMFileLoginRsp*>(
               &_IMFileLoginRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(IMFileLoginRsp& a, IMFileLoginRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(IMFileLoginRsp* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IMFileLoginRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IMFileLoginRsp* New() const final {
    return new IMFileLoginRsp();
  }

  IMFileLoginRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IMFileLoginRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IMFileLoginRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IMFileLoginRsp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IMFileLoginRsp* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IM.File.IMFileLoginRsp";
  }
  protected:
  explicit IMFileLoginRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskIdFieldNumber = 2,
    kResultCodeFieldNumber = 1,
  };
  // string task_id = 2;
  void clear_task_id();
  const std::string& task_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_task_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_task_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_task_id();
  void set_allocated_task_id(std::string* task_id);
  private:
  const std::string& _internal_task_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_task_id(const std::string& value);
  std::string* _internal_mutable_task_id();
  public:

  // uint32 result_code = 1;
  void clear_result_code();
  ::PROTOBUF_NAMESPACE_ID::uint32 result_code() const;
  void set_result_code(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_result_code() const;
  void _internal_set_result_code(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:IM.File.IMFileLoginRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr task_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 result_code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_IM_2eFile_2eproto;
};
// -------------------------------------------------------------------

class IMFileState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IM.File.IMFileState) */ {
 public:
  inline IMFileState() : IMFileState(nullptr) {}
  ~IMFileState() override;
  explicit constexpr IMFileState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IMFileState(const IMFileState& from);
  IMFileState(IMFileState&& from) noexcept
    : IMFileState() {
    *this = ::std::move(from);
  }

  inline IMFileState& operator=(const IMFileState& from) {
    CopyFrom(from);
    return *this;
  }
  inline IMFileState& operator=(IMFileState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IMFileState& default_instance() {
    return *internal_default_instance();
  }
  static inline const IMFileState* internal_default_instance() {
    return reinterpret_cast<const IMFileState*>(
               &_IMFileState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(IMFileState& a, IMFileState& b) {
    a.Swap(&b);
  }
  inline void Swap(IMFileState* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IMFileState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IMFileState* New() const final {
    return new IMFileState();
  }

  IMFileState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IMFileState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IMFileState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IMFileState& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IMFileState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IM.File.IMFileState";
  }
  protected:
  explicit IMFileState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskIdFieldNumber = 2,
    kStateFieldNumber = 1,
    kUserIdFieldNumber = 3,
  };
  // string task_id = 2;
  void clear_task_id();
  const std::string& task_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_task_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_task_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_task_id();
  void set_allocated_task_id(std::string* task_id);
  private:
  const std::string& _internal_task_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_task_id(const std::string& value);
  std::string* _internal_mutable_task_id();
  public:

  // .IM.BaseDefine.ClientFileState state = 1;
  void clear_state();
  ::IM::BaseDefine::ClientFileState state() const;
  void set_state(::IM::BaseDefine::ClientFileState value);
  private:
  ::IM::BaseDefine::ClientFileState _internal_state() const;
  void _internal_set_state(::IM::BaseDefine::ClientFileState value);
  public:

  // uint32 user_id = 3;
  void clear_user_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 user_id() const;
  void set_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_user_id() const;
  void _internal_set_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:IM.File.IMFileState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr task_id_;
  int state_;
  ::PROTOBUF_NAMESPACE_ID::uint32 user_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_IM_2eFile_2eproto;
};
// -------------------------------------------------------------------

class IMFilePullDataReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IM.File.IMFilePullDataReq) */ {
 public:
  inline IMFilePullDataReq() : IMFilePullDataReq(nullptr) {}
  ~IMFilePullDataReq() override;
  explicit constexpr IMFilePullDataReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IMFilePullDataReq(const IMFilePullDataReq& from);
  IMFilePullDataReq(IMFilePullDataReq&& from) noexcept
    : IMFilePullDataReq() {
    *this = ::std::move(from);
  }

  inline IMFilePullDataReq& operator=(const IMFilePullDataReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline IMFilePullDataReq& operator=(IMFilePullDataReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IMFilePullDataReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const IMFilePullDataReq* internal_default_instance() {
    return reinterpret_cast<const IMFilePullDataReq*>(
               &_IMFilePullDataReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(IMFilePullDataReq& a, IMFilePullDataReq& b) {
    a.Swap(&b);
  }
  inline void Swap(IMFilePullDataReq* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IMFilePullDataReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IMFilePullDataReq* New() const final {
    return new IMFilePullDataReq();
  }

  IMFilePullDataReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IMFilePullDataReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IMFilePullDataReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IMFilePullDataReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IMFilePullDataReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IM.File.IMFilePullDataReq";
  }
  protected:
  explicit IMFilePullDataReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskIdFieldNumber = 1,
    kUserIdFieldNumber = 2,
    kTransModeFieldNumber = 3,
    kOffsetFieldNumber = 4,
    kDataSizeFieldNumber = 5,
  };
  // string task_id = 1;
  void clear_task_id();
  const std::string& task_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_task_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_task_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_task_id();
  void set_allocated_task_id(std::string* task_id);
  private:
  const std::string& _internal_task_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_task_id(const std::string& value);
  std::string* _internal_mutable_task_id();
  public:

  // uint32 user_id = 2;
  void clear_user_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 user_id() const;
  void set_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_user_id() const;
  void _internal_set_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // .IM.BaseDefine.TransferFileType trans_mode = 3;
  void clear_trans_mode();
  ::IM::BaseDefine::TransferFileType trans_mode() const;
  void set_trans_mode(::IM::BaseDefine::TransferFileType value);
  private:
  ::IM::BaseDefine::TransferFileType _internal_trans_mode() const;
  void _internal_set_trans_mode(::IM::BaseDefine::TransferFileType value);
  public:

  // uint32 offset = 4;
  void clear_offset();
  ::PROTOBUF_NAMESPACE_ID::uint32 offset() const;
  void set_offset(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_offset() const;
  void _internal_set_offset(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 data_size = 5;
  void clear_data_size();
  ::PROTOBUF_NAMESPACE_ID::uint32 data_size() const;
  void set_data_size(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_data_size() const;
  void _internal_set_data_size(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:IM.File.IMFilePullDataReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr task_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 user_id_;
  int trans_mode_;
  ::PROTOBUF_NAMESPACE_ID::uint32 offset_;
  ::PROTOBUF_NAMESPACE_ID::uint32 data_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_IM_2eFile_2eproto;
};
// -------------------------------------------------------------------

class IMFilePullDataRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IM.File.IMFilePullDataRsp) */ {
 public:
  inline IMFilePullDataRsp() : IMFilePullDataRsp(nullptr) {}
  ~IMFilePullDataRsp() override;
  explicit constexpr IMFilePullDataRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IMFilePullDataRsp(const IMFilePullDataRsp& from);
  IMFilePullDataRsp(IMFilePullDataRsp&& from) noexcept
    : IMFilePullDataRsp() {
    *this = ::std::move(from);
  }

  inline IMFilePullDataRsp& operator=(const IMFilePullDataRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline IMFilePullDataRsp& operator=(IMFilePullDataRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IMFilePullDataRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const IMFilePullDataRsp* internal_default_instance() {
    return reinterpret_cast<const IMFilePullDataRsp*>(
               &_IMFilePullDataRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(IMFilePullDataRsp& a, IMFilePullDataRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(IMFilePullDataRsp* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IMFilePullDataRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IMFilePullDataRsp* New() const final {
    return new IMFilePullDataRsp();
  }

  IMFilePullDataRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IMFilePullDataRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IMFilePullDataRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IMFilePullDataRsp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IMFilePullDataRsp* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IM.File.IMFilePullDataRsp";
  }
  protected:
  explicit IMFilePullDataRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskIdFieldNumber = 2,
    kFileDataFieldNumber = 5,
    kResultCodeFieldNumber = 1,
    kUserIdFieldNumber = 3,
    kOffsetFieldNumber = 4,
  };
  // string task_id = 2;
  void clear_task_id();
  const std::string& task_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_task_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_task_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_task_id();
  void set_allocated_task_id(std::string* task_id);
  private:
  const std::string& _internal_task_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_task_id(const std::string& value);
  std::string* _internal_mutable_task_id();
  public:

  // bytes file_data = 5;
  void clear_file_data();
  const std::string& file_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_data();
  PROTOBUF_MUST_USE_RESULT std::string* release_file_data();
  void set_allocated_file_data(std::string* file_data);
  private:
  const std::string& _internal_file_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_data(const std::string& value);
  std::string* _internal_mutable_file_data();
  public:

  // uint32 result_code = 1;
  void clear_result_code();
  ::PROTOBUF_NAMESPACE_ID::uint32 result_code() const;
  void set_result_code(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_result_code() const;
  void _internal_set_result_code(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 user_id = 3;
  void clear_user_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 user_id() const;
  void set_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_user_id() const;
  void _internal_set_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 offset = 4;
  void clear_offset();
  ::PROTOBUF_NAMESPACE_ID::uint32 offset() const;
  void set_offset(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_offset() const;
  void _internal_set_offset(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:IM.File.IMFilePullDataRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr task_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_data_;
  ::PROTOBUF_NAMESPACE_ID::uint32 result_code_;
  ::PROTOBUF_NAMESPACE_ID::uint32 user_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 offset_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_IM_2eFile_2eproto;
};
// -------------------------------------------------------------------

class IMFileReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IM.File.IMFileReq) */ {
 public:
  inline IMFileReq() : IMFileReq(nullptr) {}
  ~IMFileReq() override;
  explicit constexpr IMFileReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IMFileReq(const IMFileReq& from);
  IMFileReq(IMFileReq&& from) noexcept
    : IMFileReq() {
    *this = ::std::move(from);
  }

  inline IMFileReq& operator=(const IMFileReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline IMFileReq& operator=(IMFileReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IMFileReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const IMFileReq* internal_default_instance() {
    return reinterpret_cast<const IMFileReq*>(
               &_IMFileReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(IMFileReq& a, IMFileReq& b) {
    a.Swap(&b);
  }
  inline void Swap(IMFileReq* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IMFileReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IMFileReq* New() const final {
    return new IMFileReq();
  }

  IMFileReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IMFileReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IMFileReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IMFileReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IMFileReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IM.File.IMFileReq";
  }
  protected:
  explicit IMFileReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileNameFieldNumber = 3,
    kFromUserIdFieldNumber = 1,
    kToUserIdFieldNumber = 2,
    kFileSizeFieldNumber = 4,
    kTransModeFieldNumber = 5,
  };
  // string file_name = 3;
  void clear_file_name();
  const std::string& file_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_file_name();
  void set_allocated_file_name(std::string* file_name);
  private:
  const std::string& _internal_file_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_name(const std::string& value);
  std::string* _internal_mutable_file_name();
  public:

  // uint32 from_user_id = 1;
  void clear_from_user_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 from_user_id() const;
  void set_from_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_from_user_id() const;
  void _internal_set_from_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 to_user_id = 2;
  void clear_to_user_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 to_user_id() const;
  void set_to_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_to_user_id() const;
  void _internal_set_to_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 file_size = 4;
  void clear_file_size();
  ::PROTOBUF_NAMESPACE_ID::uint32 file_size() const;
  void set_file_size(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_file_size() const;
  void _internal_set_file_size(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // .IM.BaseDefine.TransferFileType trans_mode = 5;
  void clear_trans_mode();
  ::IM::BaseDefine::TransferFileType trans_mode() const;
  void set_trans_mode(::IM::BaseDefine::TransferFileType value);
  private:
  ::IM::BaseDefine::TransferFileType _internal_trans_mode() const;
  void _internal_set_trans_mode(::IM::BaseDefine::TransferFileType value);
  public:

  // @@protoc_insertion_point(class_scope:IM.File.IMFileReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_name_;
  ::PROTOBUF_NAMESPACE_ID::uint32 from_user_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 to_user_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 file_size_;
  int trans_mode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_IM_2eFile_2eproto;
};
// -------------------------------------------------------------------

class IMFileRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IM.File.IMFileRsp) */ {
 public:
  inline IMFileRsp() : IMFileRsp(nullptr) {}
  ~IMFileRsp() override;
  explicit constexpr IMFileRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IMFileRsp(const IMFileRsp& from);
  IMFileRsp(IMFileRsp&& from) noexcept
    : IMFileRsp() {
    *this = ::std::move(from);
  }

  inline IMFileRsp& operator=(const IMFileRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline IMFileRsp& operator=(IMFileRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IMFileRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const IMFileRsp* internal_default_instance() {
    return reinterpret_cast<const IMFileRsp*>(
               &_IMFileRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(IMFileRsp& a, IMFileRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(IMFileRsp* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IMFileRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IMFileRsp* New() const final {
    return new IMFileRsp();
  }

  IMFileRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IMFileRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IMFileRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IMFileRsp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IMFileRsp* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IM.File.IMFileRsp";
  }
  protected:
  explicit IMFileRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpAddrListFieldNumber = 6,
    kFileNameFieldNumber = 4,
    kTaskIdFieldNumber = 5,
    kResultCodeFieldNumber = 1,
    kFromUserIdFieldNumber = 2,
    kToUserIdFieldNumber = 3,
    kTransModeFieldNumber = 7,
  };
  // repeated .IM.BaseDefine.IpAddr ip_addr_list = 6;
  int ip_addr_list_size() const;
  private:
  int _internal_ip_addr_list_size() const;
  public:
  void clear_ip_addr_list();
  ::IM::BaseDefine::IpAddr* mutable_ip_addr_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IM::BaseDefine::IpAddr >*
      mutable_ip_addr_list();
  private:
  const ::IM::BaseDefine::IpAddr& _internal_ip_addr_list(int index) const;
  ::IM::BaseDefine::IpAddr* _internal_add_ip_addr_list();
  public:
  const ::IM::BaseDefine::IpAddr& ip_addr_list(int index) const;
  ::IM::BaseDefine::IpAddr* add_ip_addr_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IM::BaseDefine::IpAddr >&
      ip_addr_list() const;

  // string file_name = 4;
  void clear_file_name();
  const std::string& file_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_file_name();
  void set_allocated_file_name(std::string* file_name);
  private:
  const std::string& _internal_file_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_name(const std::string& value);
  std::string* _internal_mutable_file_name();
  public:

  // string task_id = 5;
  void clear_task_id();
  const std::string& task_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_task_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_task_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_task_id();
  void set_allocated_task_id(std::string* task_id);
  private:
  const std::string& _internal_task_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_task_id(const std::string& value);
  std::string* _internal_mutable_task_id();
  public:

  // uint32 result_code = 1;
  void clear_result_code();
  ::PROTOBUF_NAMESPACE_ID::uint32 result_code() const;
  void set_result_code(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_result_code() const;
  void _internal_set_result_code(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 from_user_id = 2;
  void clear_from_user_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 from_user_id() const;
  void set_from_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_from_user_id() const;
  void _internal_set_from_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 to_user_id = 3;
  void clear_to_user_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 to_user_id() const;
  void set_to_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_to_user_id() const;
  void _internal_set_to_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // .IM.BaseDefine.TransferFileType trans_mode = 7;
  void clear_trans_mode();
  ::IM::BaseDefine::TransferFileType trans_mode() const;
  void set_trans_mode(::IM::BaseDefine::TransferFileType value);
  private:
  ::IM::BaseDefine::TransferFileType _internal_trans_mode() const;
  void _internal_set_trans_mode(::IM::BaseDefine::TransferFileType value);
  public:

  // @@protoc_insertion_point(class_scope:IM.File.IMFileRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IM::BaseDefine::IpAddr > ip_addr_list_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr task_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 result_code_;
  ::PROTOBUF_NAMESPACE_ID::uint32 from_user_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 to_user_id_;
  int trans_mode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_IM_2eFile_2eproto;
};
// -------------------------------------------------------------------

class IMFileNotify final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IM.File.IMFileNotify) */ {
 public:
  inline IMFileNotify() : IMFileNotify(nullptr) {}
  ~IMFileNotify() override;
  explicit constexpr IMFileNotify(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IMFileNotify(const IMFileNotify& from);
  IMFileNotify(IMFileNotify&& from) noexcept
    : IMFileNotify() {
    *this = ::std::move(from);
  }

  inline IMFileNotify& operator=(const IMFileNotify& from) {
    CopyFrom(from);
    return *this;
  }
  inline IMFileNotify& operator=(IMFileNotify&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IMFileNotify& default_instance() {
    return *internal_default_instance();
  }
  static inline const IMFileNotify* internal_default_instance() {
    return reinterpret_cast<const IMFileNotify*>(
               &_IMFileNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(IMFileNotify& a, IMFileNotify& b) {
    a.Swap(&b);
  }
  inline void Swap(IMFileNotify* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IMFileNotify* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IMFileNotify* New() const final {
    return new IMFileNotify();
  }

  IMFileNotify* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IMFileNotify>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IMFileNotify& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IMFileNotify& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IMFileNotify* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IM.File.IMFileNotify";
  }
  protected:
  explicit IMFileNotify(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpAddrListFieldNumber = 6,
    kFileNameFieldNumber = 3,
    kTaskIdFieldNumber = 5,
    kFromUserIdFieldNumber = 1,
    kToUserIdFieldNumber = 2,
    kFileSizeFieldNumber = 4,
    kTransModeFieldNumber = 7,
    kOfflineReadyFieldNumber = 8,
  };
  // repeated .IM.BaseDefine.IpAddr ip_addr_list = 6;
  int ip_addr_list_size() const;
  private:
  int _internal_ip_addr_list_size() const;
  public:
  void clear_ip_addr_list();
  ::IM::BaseDefine::IpAddr* mutable_ip_addr_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IM::BaseDefine::IpAddr >*
      mutable_ip_addr_list();
  private:
  const ::IM::BaseDefine::IpAddr& _internal_ip_addr_list(int index) const;
  ::IM::BaseDefine::IpAddr* _internal_add_ip_addr_list();
  public:
  const ::IM::BaseDefine::IpAddr& ip_addr_list(int index) const;
  ::IM::BaseDefine::IpAddr* add_ip_addr_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IM::BaseDefine::IpAddr >&
      ip_addr_list() const;

  // string file_name = 3;
  void clear_file_name();
  const std::string& file_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_file_name();
  void set_allocated_file_name(std::string* file_name);
  private:
  const std::string& _internal_file_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_name(const std::string& value);
  std::string* _internal_mutable_file_name();
  public:

  // string task_id = 5;
  void clear_task_id();
  const std::string& task_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_task_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_task_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_task_id();
  void set_allocated_task_id(std::string* task_id);
  private:
  const std::string& _internal_task_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_task_id(const std::string& value);
  std::string* _internal_mutable_task_id();
  public:

  // uint32 from_user_id = 1;
  void clear_from_user_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 from_user_id() const;
  void set_from_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_from_user_id() const;
  void _internal_set_from_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 to_user_id = 2;
  void clear_to_user_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 to_user_id() const;
  void set_to_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_to_user_id() const;
  void _internal_set_to_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 file_size = 4;
  void clear_file_size();
  ::PROTOBUF_NAMESPACE_ID::uint32 file_size() const;
  void set_file_size(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_file_size() const;
  void _internal_set_file_size(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // .IM.BaseDefine.TransferFileType trans_mode = 7;
  void clear_trans_mode();
  ::IM::BaseDefine::TransferFileType trans_mode() const;
  void set_trans_mode(::IM::BaseDefine::TransferFileType value);
  private:
  ::IM::BaseDefine::TransferFileType _internal_trans_mode() const;
  void _internal_set_trans_mode(::IM::BaseDefine::TransferFileType value);
  public:

  // uint32 offline_ready = 8;
  void clear_offline_ready();
  ::PROTOBUF_NAMESPACE_ID::uint32 offline_ready() const;
  void set_offline_ready(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_offline_ready() const;
  void _internal_set_offline_ready(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:IM.File.IMFileNotify)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IM::BaseDefine::IpAddr > ip_addr_list_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr task_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 from_user_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 to_user_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 file_size_;
  int trans_mode_;
  ::PROTOBUF_NAMESPACE_ID::uint32 offline_ready_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_IM_2eFile_2eproto;
};
// -------------------------------------------------------------------

class IMFileHasOfflineReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IM.File.IMFileHasOfflineReq) */ {
 public:
  inline IMFileHasOfflineReq() : IMFileHasOfflineReq(nullptr) {}
  ~IMFileHasOfflineReq() override;
  explicit constexpr IMFileHasOfflineReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IMFileHasOfflineReq(const IMFileHasOfflineReq& from);
  IMFileHasOfflineReq(IMFileHasOfflineReq&& from) noexcept
    : IMFileHasOfflineReq() {
    *this = ::std::move(from);
  }

  inline IMFileHasOfflineReq& operator=(const IMFileHasOfflineReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline IMFileHasOfflineReq& operator=(IMFileHasOfflineReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IMFileHasOfflineReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const IMFileHasOfflineReq* internal_default_instance() {
    return reinterpret_cast<const IMFileHasOfflineReq*>(
               &_IMFileHasOfflineReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(IMFileHasOfflineReq& a, IMFileHasOfflineReq& b) {
    a.Swap(&b);
  }
  inline void Swap(IMFileHasOfflineReq* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IMFileHasOfflineReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IMFileHasOfflineReq* New() const final {
    return new IMFileHasOfflineReq();
  }

  IMFileHasOfflineReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IMFileHasOfflineReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IMFileHasOfflineReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IMFileHasOfflineReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IMFileHasOfflineReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IM.File.IMFileHasOfflineReq";
  }
  protected:
  explicit IMFileHasOfflineReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttachDataFieldNumber = 20,
    kUserIdFieldNumber = 1,
  };
  // bytes attach_data = 20;
  void clear_attach_data();
  const std::string& attach_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_attach_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_attach_data();
  PROTOBUF_MUST_USE_RESULT std::string* release_attach_data();
  void set_allocated_attach_data(std::string* attach_data);
  private:
  const std::string& _internal_attach_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attach_data(const std::string& value);
  std::string* _internal_mutable_attach_data();
  public:

  // uint32 user_id = 1;
  void clear_user_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 user_id() const;
  void set_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_user_id() const;
  void _internal_set_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:IM.File.IMFileHasOfflineReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attach_data_;
  ::PROTOBUF_NAMESPACE_ID::uint32 user_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_IM_2eFile_2eproto;
};
// -------------------------------------------------------------------

class IMFileHasOfflineRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IM.File.IMFileHasOfflineRsp) */ {
 public:
  inline IMFileHasOfflineRsp() : IMFileHasOfflineRsp(nullptr) {}
  ~IMFileHasOfflineRsp() override;
  explicit constexpr IMFileHasOfflineRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IMFileHasOfflineRsp(const IMFileHasOfflineRsp& from);
  IMFileHasOfflineRsp(IMFileHasOfflineRsp&& from) noexcept
    : IMFileHasOfflineRsp() {
    *this = ::std::move(from);
  }

  inline IMFileHasOfflineRsp& operator=(const IMFileHasOfflineRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline IMFileHasOfflineRsp& operator=(IMFileHasOfflineRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IMFileHasOfflineRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const IMFileHasOfflineRsp* internal_default_instance() {
    return reinterpret_cast<const IMFileHasOfflineRsp*>(
               &_IMFileHasOfflineRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(IMFileHasOfflineRsp& a, IMFileHasOfflineRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(IMFileHasOfflineRsp* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IMFileHasOfflineRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IMFileHasOfflineRsp* New() const final {
    return new IMFileHasOfflineRsp();
  }

  IMFileHasOfflineRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IMFileHasOfflineRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IMFileHasOfflineRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IMFileHasOfflineRsp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IMFileHasOfflineRsp* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IM.File.IMFileHasOfflineRsp";
  }
  protected:
  explicit IMFileHasOfflineRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOfflineFileListFieldNumber = 2,
    kIpAddrListFieldNumber = 3,
    kAttachDataFieldNumber = 20,
    kUserIdFieldNumber = 1,
  };
  // repeated .IM.BaseDefine.OfflineFileInfo offline_file_list = 2;
  int offline_file_list_size() const;
  private:
  int _internal_offline_file_list_size() const;
  public:
  void clear_offline_file_list();
  ::IM::BaseDefine::OfflineFileInfo* mutable_offline_file_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IM::BaseDefine::OfflineFileInfo >*
      mutable_offline_file_list();
  private:
  const ::IM::BaseDefine::OfflineFileInfo& _internal_offline_file_list(int index) const;
  ::IM::BaseDefine::OfflineFileInfo* _internal_add_offline_file_list();
  public:
  const ::IM::BaseDefine::OfflineFileInfo& offline_file_list(int index) const;
  ::IM::BaseDefine::OfflineFileInfo* add_offline_file_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IM::BaseDefine::OfflineFileInfo >&
      offline_file_list() const;

  // repeated .IM.BaseDefine.IpAddr ip_addr_list = 3;
  int ip_addr_list_size() const;
  private:
  int _internal_ip_addr_list_size() const;
  public:
  void clear_ip_addr_list();
  ::IM::BaseDefine::IpAddr* mutable_ip_addr_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IM::BaseDefine::IpAddr >*
      mutable_ip_addr_list();
  private:
  const ::IM::BaseDefine::IpAddr& _internal_ip_addr_list(int index) const;
  ::IM::BaseDefine::IpAddr* _internal_add_ip_addr_list();
  public:
  const ::IM::BaseDefine::IpAddr& ip_addr_list(int index) const;
  ::IM::BaseDefine::IpAddr* add_ip_addr_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IM::BaseDefine::IpAddr >&
      ip_addr_list() const;

  // bytes attach_data = 20;
  void clear_attach_data();
  const std::string& attach_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_attach_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_attach_data();
  PROTOBUF_MUST_USE_RESULT std::string* release_attach_data();
  void set_allocated_attach_data(std::string* attach_data);
  private:
  const std::string& _internal_attach_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attach_data(const std::string& value);
  std::string* _internal_mutable_attach_data();
  public:

  // uint32 user_id = 1;
  void clear_user_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 user_id() const;
  void set_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_user_id() const;
  void _internal_set_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:IM.File.IMFileHasOfflineRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IM::BaseDefine::OfflineFileInfo > offline_file_list_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IM::BaseDefine::IpAddr > ip_addr_list_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attach_data_;
  ::PROTOBUF_NAMESPACE_ID::uint32 user_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_IM_2eFile_2eproto;
};
// -------------------------------------------------------------------

class IMFileAddOfflineReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IM.File.IMFileAddOfflineReq) */ {
 public:
  inline IMFileAddOfflineReq() : IMFileAddOfflineReq(nullptr) {}
  ~IMFileAddOfflineReq() override;
  explicit constexpr IMFileAddOfflineReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IMFileAddOfflineReq(const IMFileAddOfflineReq& from);
  IMFileAddOfflineReq(IMFileAddOfflineReq&& from) noexcept
    : IMFileAddOfflineReq() {
    *this = ::std::move(from);
  }

  inline IMFileAddOfflineReq& operator=(const IMFileAddOfflineReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline IMFileAddOfflineReq& operator=(IMFileAddOfflineReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IMFileAddOfflineReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const IMFileAddOfflineReq* internal_default_instance() {
    return reinterpret_cast<const IMFileAddOfflineReq*>(
               &_IMFileAddOfflineReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(IMFileAddOfflineReq& a, IMFileAddOfflineReq& b) {
    a.Swap(&b);
  }
  inline void Swap(IMFileAddOfflineReq* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IMFileAddOfflineReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IMFileAddOfflineReq* New() const final {
    return new IMFileAddOfflineReq();
  }

  IMFileAddOfflineReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IMFileAddOfflineReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IMFileAddOfflineReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IMFileAddOfflineReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IMFileAddOfflineReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IM.File.IMFileAddOfflineReq";
  }
  protected:
  explicit IMFileAddOfflineReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskIdFieldNumber = 3,
    kFileNameFieldNumber = 4,
    kFromUserIdFieldNumber = 1,
    kToUserIdFieldNumber = 2,
    kFileSizeFieldNumber = 5,
  };
  // string task_id = 3;
  void clear_task_id();
  const std::string& task_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_task_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_task_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_task_id();
  void set_allocated_task_id(std::string* task_id);
  private:
  const std::string& _internal_task_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_task_id(const std::string& value);
  std::string* _internal_mutable_task_id();
  public:

  // string file_name = 4;
  void clear_file_name();
  const std::string& file_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_file_name();
  void set_allocated_file_name(std::string* file_name);
  private:
  const std::string& _internal_file_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_name(const std::string& value);
  std::string* _internal_mutable_file_name();
  public:

  // uint32 from_user_id = 1;
  void clear_from_user_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 from_user_id() const;
  void set_from_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_from_user_id() const;
  void _internal_set_from_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 to_user_id = 2;
  void clear_to_user_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 to_user_id() const;
  void set_to_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_to_user_id() const;
  void _internal_set_to_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 file_size = 5;
  void clear_file_size();
  ::PROTOBUF_NAMESPACE_ID::uint32 file_size() const;
  void set_file_size(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_file_size() const;
  void _internal_set_file_size(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:IM.File.IMFileAddOfflineReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr task_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_name_;
  ::PROTOBUF_NAMESPACE_ID::uint32 from_user_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 to_user_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 file_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_IM_2eFile_2eproto;
};
// -------------------------------------------------------------------

class IMFileDelOfflineReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IM.File.IMFileDelOfflineReq) */ {
 public:
  inline IMFileDelOfflineReq() : IMFileDelOfflineReq(nullptr) {}
  ~IMFileDelOfflineReq() override;
  explicit constexpr IMFileDelOfflineReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IMFileDelOfflineReq(const IMFileDelOfflineReq& from);
  IMFileDelOfflineReq(IMFileDelOfflineReq&& from) noexcept
    : IMFileDelOfflineReq() {
    *this = ::std::move(from);
  }

  inline IMFileDelOfflineReq& operator=(const IMFileDelOfflineReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline IMFileDelOfflineReq& operator=(IMFileDelOfflineReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IMFileDelOfflineReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const IMFileDelOfflineReq* internal_default_instance() {
    return reinterpret_cast<const IMFileDelOfflineReq*>(
               &_IMFileDelOfflineReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(IMFileDelOfflineReq& a, IMFileDelOfflineReq& b) {
    a.Swap(&b);
  }
  inline void Swap(IMFileDelOfflineReq* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IMFileDelOfflineReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IMFileDelOfflineReq* New() const final {
    return new IMFileDelOfflineReq();
  }

  IMFileDelOfflineReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IMFileDelOfflineReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IMFileDelOfflineReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IMFileDelOfflineReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IMFileDelOfflineReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IM.File.IMFileDelOfflineReq";
  }
  protected:
  explicit IMFileDelOfflineReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskIdFieldNumber = 3,
    kFromUserIdFieldNumber = 1,
    kToUserIdFieldNumber = 2,
  };
  // string task_id = 3;
  void clear_task_id();
  const std::string& task_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_task_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_task_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_task_id();
  void set_allocated_task_id(std::string* task_id);
  private:
  const std::string& _internal_task_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_task_id(const std::string& value);
  std::string* _internal_mutable_task_id();
  public:

  // uint32 from_user_id = 1;
  void clear_from_user_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 from_user_id() const;
  void set_from_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_from_user_id() const;
  void _internal_set_from_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 to_user_id = 2;
  void clear_to_user_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 to_user_id() const;
  void set_to_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_to_user_id() const;
  void _internal_set_to_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:IM.File.IMFileDelOfflineReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr task_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 from_user_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 to_user_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_IM_2eFile_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// IMFileLoginReq

// uint32 user_id = 1;
inline void IMFileLoginReq::clear_user_id() {
  user_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IMFileLoginReq::_internal_user_id() const {
  return user_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IMFileLoginReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileLoginReq.user_id)
  return _internal_user_id();
}
inline void IMFileLoginReq::_internal_set_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  user_id_ = value;
}
inline void IMFileLoginReq::set_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:IM.File.IMFileLoginReq.user_id)
}

// string task_id = 2;
inline void IMFileLoginReq::clear_task_id() {
  task_id_.ClearToEmpty();
}
inline const std::string& IMFileLoginReq::task_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileLoginReq.task_id)
  return _internal_task_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IMFileLoginReq::set_task_id(ArgT0&& arg0, ArgT... args) {
 
 task_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IM.File.IMFileLoginReq.task_id)
}
inline std::string* IMFileLoginReq::mutable_task_id() {
  std::string* _s = _internal_mutable_task_id();
  // @@protoc_insertion_point(field_mutable:IM.File.IMFileLoginReq.task_id)
  return _s;
}
inline const std::string& IMFileLoginReq::_internal_task_id() const {
  return task_id_.Get();
}
inline void IMFileLoginReq::_internal_set_task_id(const std::string& value) {
  
  task_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* IMFileLoginReq::_internal_mutable_task_id() {
  
  return task_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* IMFileLoginReq::release_task_id() {
  // @@protoc_insertion_point(field_release:IM.File.IMFileLoginReq.task_id)
  return task_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void IMFileLoginReq::set_allocated_task_id(std::string* task_id) {
  if (task_id != nullptr) {
    
  } else {
    
  }
  task_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), task_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:IM.File.IMFileLoginReq.task_id)
}

// .IM.BaseDefine.ClientFileRole file_role = 3;
inline void IMFileLoginReq::clear_file_role() {
  file_role_ = 0;
}
inline ::IM::BaseDefine::ClientFileRole IMFileLoginReq::_internal_file_role() const {
  return static_cast< ::IM::BaseDefine::ClientFileRole >(file_role_);
}
inline ::IM::BaseDefine::ClientFileRole IMFileLoginReq::file_role() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileLoginReq.file_role)
  return _internal_file_role();
}
inline void IMFileLoginReq::_internal_set_file_role(::IM::BaseDefine::ClientFileRole value) {
  
  file_role_ = value;
}
inline void IMFileLoginReq::set_file_role(::IM::BaseDefine::ClientFileRole value) {
  _internal_set_file_role(value);
  // @@protoc_insertion_point(field_set:IM.File.IMFileLoginReq.file_role)
}

// -------------------------------------------------------------------

// IMFileLoginRsp

// uint32 result_code = 1;
inline void IMFileLoginRsp::clear_result_code() {
  result_code_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IMFileLoginRsp::_internal_result_code() const {
  return result_code_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IMFileLoginRsp::result_code() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileLoginRsp.result_code)
  return _internal_result_code();
}
inline void IMFileLoginRsp::_internal_set_result_code(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  result_code_ = value;
}
inline void IMFileLoginRsp::set_result_code(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_result_code(value);
  // @@protoc_insertion_point(field_set:IM.File.IMFileLoginRsp.result_code)
}

// string task_id = 2;
inline void IMFileLoginRsp::clear_task_id() {
  task_id_.ClearToEmpty();
}
inline const std::string& IMFileLoginRsp::task_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileLoginRsp.task_id)
  return _internal_task_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IMFileLoginRsp::set_task_id(ArgT0&& arg0, ArgT... args) {
 
 task_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IM.File.IMFileLoginRsp.task_id)
}
inline std::string* IMFileLoginRsp::mutable_task_id() {
  std::string* _s = _internal_mutable_task_id();
  // @@protoc_insertion_point(field_mutable:IM.File.IMFileLoginRsp.task_id)
  return _s;
}
inline const std::string& IMFileLoginRsp::_internal_task_id() const {
  return task_id_.Get();
}
inline void IMFileLoginRsp::_internal_set_task_id(const std::string& value) {
  
  task_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* IMFileLoginRsp::_internal_mutable_task_id() {
  
  return task_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* IMFileLoginRsp::release_task_id() {
  // @@protoc_insertion_point(field_release:IM.File.IMFileLoginRsp.task_id)
  return task_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void IMFileLoginRsp::set_allocated_task_id(std::string* task_id) {
  if (task_id != nullptr) {
    
  } else {
    
  }
  task_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), task_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:IM.File.IMFileLoginRsp.task_id)
}

// -------------------------------------------------------------------

// IMFileState

// .IM.BaseDefine.ClientFileState state = 1;
inline void IMFileState::clear_state() {
  state_ = 0;
}
inline ::IM::BaseDefine::ClientFileState IMFileState::_internal_state() const {
  return static_cast< ::IM::BaseDefine::ClientFileState >(state_);
}
inline ::IM::BaseDefine::ClientFileState IMFileState::state() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileState.state)
  return _internal_state();
}
inline void IMFileState::_internal_set_state(::IM::BaseDefine::ClientFileState value) {
  
  state_ = value;
}
inline void IMFileState::set_state(::IM::BaseDefine::ClientFileState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:IM.File.IMFileState.state)
}

// string task_id = 2;
inline void IMFileState::clear_task_id() {
  task_id_.ClearToEmpty();
}
inline const std::string& IMFileState::task_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileState.task_id)
  return _internal_task_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IMFileState::set_task_id(ArgT0&& arg0, ArgT... args) {
 
 task_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IM.File.IMFileState.task_id)
}
inline std::string* IMFileState::mutable_task_id() {
  std::string* _s = _internal_mutable_task_id();
  // @@protoc_insertion_point(field_mutable:IM.File.IMFileState.task_id)
  return _s;
}
inline const std::string& IMFileState::_internal_task_id() const {
  return task_id_.Get();
}
inline void IMFileState::_internal_set_task_id(const std::string& value) {
  
  task_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* IMFileState::_internal_mutable_task_id() {
  
  return task_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* IMFileState::release_task_id() {
  // @@protoc_insertion_point(field_release:IM.File.IMFileState.task_id)
  return task_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void IMFileState::set_allocated_task_id(std::string* task_id) {
  if (task_id != nullptr) {
    
  } else {
    
  }
  task_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), task_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:IM.File.IMFileState.task_id)
}

// uint32 user_id = 3;
inline void IMFileState::clear_user_id() {
  user_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IMFileState::_internal_user_id() const {
  return user_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IMFileState::user_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileState.user_id)
  return _internal_user_id();
}
inline void IMFileState::_internal_set_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  user_id_ = value;
}
inline void IMFileState::set_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:IM.File.IMFileState.user_id)
}

// -------------------------------------------------------------------

// IMFilePullDataReq

// string task_id = 1;
inline void IMFilePullDataReq::clear_task_id() {
  task_id_.ClearToEmpty();
}
inline const std::string& IMFilePullDataReq::task_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFilePullDataReq.task_id)
  return _internal_task_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IMFilePullDataReq::set_task_id(ArgT0&& arg0, ArgT... args) {
 
 task_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IM.File.IMFilePullDataReq.task_id)
}
inline std::string* IMFilePullDataReq::mutable_task_id() {
  std::string* _s = _internal_mutable_task_id();
  // @@protoc_insertion_point(field_mutable:IM.File.IMFilePullDataReq.task_id)
  return _s;
}
inline const std::string& IMFilePullDataReq::_internal_task_id() const {
  return task_id_.Get();
}
inline void IMFilePullDataReq::_internal_set_task_id(const std::string& value) {
  
  task_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* IMFilePullDataReq::_internal_mutable_task_id() {
  
  return task_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* IMFilePullDataReq::release_task_id() {
  // @@protoc_insertion_point(field_release:IM.File.IMFilePullDataReq.task_id)
  return task_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void IMFilePullDataReq::set_allocated_task_id(std::string* task_id) {
  if (task_id != nullptr) {
    
  } else {
    
  }
  task_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), task_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:IM.File.IMFilePullDataReq.task_id)
}

// uint32 user_id = 2;
inline void IMFilePullDataReq::clear_user_id() {
  user_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IMFilePullDataReq::_internal_user_id() const {
  return user_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IMFilePullDataReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFilePullDataReq.user_id)
  return _internal_user_id();
}
inline void IMFilePullDataReq::_internal_set_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  user_id_ = value;
}
inline void IMFilePullDataReq::set_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:IM.File.IMFilePullDataReq.user_id)
}

// .IM.BaseDefine.TransferFileType trans_mode = 3;
inline void IMFilePullDataReq::clear_trans_mode() {
  trans_mode_ = 0;
}
inline ::IM::BaseDefine::TransferFileType IMFilePullDataReq::_internal_trans_mode() const {
  return static_cast< ::IM::BaseDefine::TransferFileType >(trans_mode_);
}
inline ::IM::BaseDefine::TransferFileType IMFilePullDataReq::trans_mode() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFilePullDataReq.trans_mode)
  return _internal_trans_mode();
}
inline void IMFilePullDataReq::_internal_set_trans_mode(::IM::BaseDefine::TransferFileType value) {
  
  trans_mode_ = value;
}
inline void IMFilePullDataReq::set_trans_mode(::IM::BaseDefine::TransferFileType value) {
  _internal_set_trans_mode(value);
  // @@protoc_insertion_point(field_set:IM.File.IMFilePullDataReq.trans_mode)
}

// uint32 offset = 4;
inline void IMFilePullDataReq::clear_offset() {
  offset_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IMFilePullDataReq::_internal_offset() const {
  return offset_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IMFilePullDataReq::offset() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFilePullDataReq.offset)
  return _internal_offset();
}
inline void IMFilePullDataReq::_internal_set_offset(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  offset_ = value;
}
inline void IMFilePullDataReq::set_offset(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:IM.File.IMFilePullDataReq.offset)
}

// uint32 data_size = 5;
inline void IMFilePullDataReq::clear_data_size() {
  data_size_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IMFilePullDataReq::_internal_data_size() const {
  return data_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IMFilePullDataReq::data_size() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFilePullDataReq.data_size)
  return _internal_data_size();
}
inline void IMFilePullDataReq::_internal_set_data_size(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  data_size_ = value;
}
inline void IMFilePullDataReq::set_data_size(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_data_size(value);
  // @@protoc_insertion_point(field_set:IM.File.IMFilePullDataReq.data_size)
}

// -------------------------------------------------------------------

// IMFilePullDataRsp

// uint32 result_code = 1;
inline void IMFilePullDataRsp::clear_result_code() {
  result_code_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IMFilePullDataRsp::_internal_result_code() const {
  return result_code_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IMFilePullDataRsp::result_code() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFilePullDataRsp.result_code)
  return _internal_result_code();
}
inline void IMFilePullDataRsp::_internal_set_result_code(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  result_code_ = value;
}
inline void IMFilePullDataRsp::set_result_code(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_result_code(value);
  // @@protoc_insertion_point(field_set:IM.File.IMFilePullDataRsp.result_code)
}

// string task_id = 2;
inline void IMFilePullDataRsp::clear_task_id() {
  task_id_.ClearToEmpty();
}
inline const std::string& IMFilePullDataRsp::task_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFilePullDataRsp.task_id)
  return _internal_task_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IMFilePullDataRsp::set_task_id(ArgT0&& arg0, ArgT... args) {
 
 task_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IM.File.IMFilePullDataRsp.task_id)
}
inline std::string* IMFilePullDataRsp::mutable_task_id() {
  std::string* _s = _internal_mutable_task_id();
  // @@protoc_insertion_point(field_mutable:IM.File.IMFilePullDataRsp.task_id)
  return _s;
}
inline const std::string& IMFilePullDataRsp::_internal_task_id() const {
  return task_id_.Get();
}
inline void IMFilePullDataRsp::_internal_set_task_id(const std::string& value) {
  
  task_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* IMFilePullDataRsp::_internal_mutable_task_id() {
  
  return task_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* IMFilePullDataRsp::release_task_id() {
  // @@protoc_insertion_point(field_release:IM.File.IMFilePullDataRsp.task_id)
  return task_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void IMFilePullDataRsp::set_allocated_task_id(std::string* task_id) {
  if (task_id != nullptr) {
    
  } else {
    
  }
  task_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), task_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:IM.File.IMFilePullDataRsp.task_id)
}

// uint32 user_id = 3;
inline void IMFilePullDataRsp::clear_user_id() {
  user_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IMFilePullDataRsp::_internal_user_id() const {
  return user_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IMFilePullDataRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFilePullDataRsp.user_id)
  return _internal_user_id();
}
inline void IMFilePullDataRsp::_internal_set_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  user_id_ = value;
}
inline void IMFilePullDataRsp::set_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:IM.File.IMFilePullDataRsp.user_id)
}

// uint32 offset = 4;
inline void IMFilePullDataRsp::clear_offset() {
  offset_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IMFilePullDataRsp::_internal_offset() const {
  return offset_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IMFilePullDataRsp::offset() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFilePullDataRsp.offset)
  return _internal_offset();
}
inline void IMFilePullDataRsp::_internal_set_offset(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  offset_ = value;
}
inline void IMFilePullDataRsp::set_offset(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:IM.File.IMFilePullDataRsp.offset)
}

// bytes file_data = 5;
inline void IMFilePullDataRsp::clear_file_data() {
  file_data_.ClearToEmpty();
}
inline const std::string& IMFilePullDataRsp::file_data() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFilePullDataRsp.file_data)
  return _internal_file_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IMFilePullDataRsp::set_file_data(ArgT0&& arg0, ArgT... args) {
 
 file_data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IM.File.IMFilePullDataRsp.file_data)
}
inline std::string* IMFilePullDataRsp::mutable_file_data() {
  std::string* _s = _internal_mutable_file_data();
  // @@protoc_insertion_point(field_mutable:IM.File.IMFilePullDataRsp.file_data)
  return _s;
}
inline const std::string& IMFilePullDataRsp::_internal_file_data() const {
  return file_data_.Get();
}
inline void IMFilePullDataRsp::_internal_set_file_data(const std::string& value) {
  
  file_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* IMFilePullDataRsp::_internal_mutable_file_data() {
  
  return file_data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* IMFilePullDataRsp::release_file_data() {
  // @@protoc_insertion_point(field_release:IM.File.IMFilePullDataRsp.file_data)
  return file_data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void IMFilePullDataRsp::set_allocated_file_data(std::string* file_data) {
  if (file_data != nullptr) {
    
  } else {
    
  }
  file_data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_data,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:IM.File.IMFilePullDataRsp.file_data)
}

// -------------------------------------------------------------------

// IMFileReq

// uint32 from_user_id = 1;
inline void IMFileReq::clear_from_user_id() {
  from_user_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IMFileReq::_internal_from_user_id() const {
  return from_user_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IMFileReq::from_user_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileReq.from_user_id)
  return _internal_from_user_id();
}
inline void IMFileReq::_internal_set_from_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  from_user_id_ = value;
}
inline void IMFileReq::set_from_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_from_user_id(value);
  // @@protoc_insertion_point(field_set:IM.File.IMFileReq.from_user_id)
}

// uint32 to_user_id = 2;
inline void IMFileReq::clear_to_user_id() {
  to_user_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IMFileReq::_internal_to_user_id() const {
  return to_user_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IMFileReq::to_user_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileReq.to_user_id)
  return _internal_to_user_id();
}
inline void IMFileReq::_internal_set_to_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  to_user_id_ = value;
}
inline void IMFileReq::set_to_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_to_user_id(value);
  // @@protoc_insertion_point(field_set:IM.File.IMFileReq.to_user_id)
}

// string file_name = 3;
inline void IMFileReq::clear_file_name() {
  file_name_.ClearToEmpty();
}
inline const std::string& IMFileReq::file_name() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileReq.file_name)
  return _internal_file_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IMFileReq::set_file_name(ArgT0&& arg0, ArgT... args) {
 
 file_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IM.File.IMFileReq.file_name)
}
inline std::string* IMFileReq::mutable_file_name() {
  std::string* _s = _internal_mutable_file_name();
  // @@protoc_insertion_point(field_mutable:IM.File.IMFileReq.file_name)
  return _s;
}
inline const std::string& IMFileReq::_internal_file_name() const {
  return file_name_.Get();
}
inline void IMFileReq::_internal_set_file_name(const std::string& value) {
  
  file_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* IMFileReq::_internal_mutable_file_name() {
  
  return file_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* IMFileReq::release_file_name() {
  // @@protoc_insertion_point(field_release:IM.File.IMFileReq.file_name)
  return file_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void IMFileReq::set_allocated_file_name(std::string* file_name) {
  if (file_name != nullptr) {
    
  } else {
    
  }
  file_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:IM.File.IMFileReq.file_name)
}

// uint32 file_size = 4;
inline void IMFileReq::clear_file_size() {
  file_size_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IMFileReq::_internal_file_size() const {
  return file_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IMFileReq::file_size() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileReq.file_size)
  return _internal_file_size();
}
inline void IMFileReq::_internal_set_file_size(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  file_size_ = value;
}
inline void IMFileReq::set_file_size(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_file_size(value);
  // @@protoc_insertion_point(field_set:IM.File.IMFileReq.file_size)
}

// .IM.BaseDefine.TransferFileType trans_mode = 5;
inline void IMFileReq::clear_trans_mode() {
  trans_mode_ = 0;
}
inline ::IM::BaseDefine::TransferFileType IMFileReq::_internal_trans_mode() const {
  return static_cast< ::IM::BaseDefine::TransferFileType >(trans_mode_);
}
inline ::IM::BaseDefine::TransferFileType IMFileReq::trans_mode() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileReq.trans_mode)
  return _internal_trans_mode();
}
inline void IMFileReq::_internal_set_trans_mode(::IM::BaseDefine::TransferFileType value) {
  
  trans_mode_ = value;
}
inline void IMFileReq::set_trans_mode(::IM::BaseDefine::TransferFileType value) {
  _internal_set_trans_mode(value);
  // @@protoc_insertion_point(field_set:IM.File.IMFileReq.trans_mode)
}

// -------------------------------------------------------------------

// IMFileRsp

// uint32 result_code = 1;
inline void IMFileRsp::clear_result_code() {
  result_code_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IMFileRsp::_internal_result_code() const {
  return result_code_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IMFileRsp::result_code() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileRsp.result_code)
  return _internal_result_code();
}
inline void IMFileRsp::_internal_set_result_code(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  result_code_ = value;
}
inline void IMFileRsp::set_result_code(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_result_code(value);
  // @@protoc_insertion_point(field_set:IM.File.IMFileRsp.result_code)
}

// uint32 from_user_id = 2;
inline void IMFileRsp::clear_from_user_id() {
  from_user_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IMFileRsp::_internal_from_user_id() const {
  return from_user_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IMFileRsp::from_user_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileRsp.from_user_id)
  return _internal_from_user_id();
}
inline void IMFileRsp::_internal_set_from_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  from_user_id_ = value;
}
inline void IMFileRsp::set_from_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_from_user_id(value);
  // @@protoc_insertion_point(field_set:IM.File.IMFileRsp.from_user_id)
}

// uint32 to_user_id = 3;
inline void IMFileRsp::clear_to_user_id() {
  to_user_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IMFileRsp::_internal_to_user_id() const {
  return to_user_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IMFileRsp::to_user_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileRsp.to_user_id)
  return _internal_to_user_id();
}
inline void IMFileRsp::_internal_set_to_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  to_user_id_ = value;
}
inline void IMFileRsp::set_to_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_to_user_id(value);
  // @@protoc_insertion_point(field_set:IM.File.IMFileRsp.to_user_id)
}

// string file_name = 4;
inline void IMFileRsp::clear_file_name() {
  file_name_.ClearToEmpty();
}
inline const std::string& IMFileRsp::file_name() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileRsp.file_name)
  return _internal_file_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IMFileRsp::set_file_name(ArgT0&& arg0, ArgT... args) {
 
 file_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IM.File.IMFileRsp.file_name)
}
inline std::string* IMFileRsp::mutable_file_name() {
  std::string* _s = _internal_mutable_file_name();
  // @@protoc_insertion_point(field_mutable:IM.File.IMFileRsp.file_name)
  return _s;
}
inline const std::string& IMFileRsp::_internal_file_name() const {
  return file_name_.Get();
}
inline void IMFileRsp::_internal_set_file_name(const std::string& value) {
  
  file_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* IMFileRsp::_internal_mutable_file_name() {
  
  return file_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* IMFileRsp::release_file_name() {
  // @@protoc_insertion_point(field_release:IM.File.IMFileRsp.file_name)
  return file_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void IMFileRsp::set_allocated_file_name(std::string* file_name) {
  if (file_name != nullptr) {
    
  } else {
    
  }
  file_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:IM.File.IMFileRsp.file_name)
}

// string task_id = 5;
inline void IMFileRsp::clear_task_id() {
  task_id_.ClearToEmpty();
}
inline const std::string& IMFileRsp::task_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileRsp.task_id)
  return _internal_task_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IMFileRsp::set_task_id(ArgT0&& arg0, ArgT... args) {
 
 task_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IM.File.IMFileRsp.task_id)
}
inline std::string* IMFileRsp::mutable_task_id() {
  std::string* _s = _internal_mutable_task_id();
  // @@protoc_insertion_point(field_mutable:IM.File.IMFileRsp.task_id)
  return _s;
}
inline const std::string& IMFileRsp::_internal_task_id() const {
  return task_id_.Get();
}
inline void IMFileRsp::_internal_set_task_id(const std::string& value) {
  
  task_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* IMFileRsp::_internal_mutable_task_id() {
  
  return task_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* IMFileRsp::release_task_id() {
  // @@protoc_insertion_point(field_release:IM.File.IMFileRsp.task_id)
  return task_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void IMFileRsp::set_allocated_task_id(std::string* task_id) {
  if (task_id != nullptr) {
    
  } else {
    
  }
  task_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), task_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:IM.File.IMFileRsp.task_id)
}

// repeated .IM.BaseDefine.IpAddr ip_addr_list = 6;
inline int IMFileRsp::_internal_ip_addr_list_size() const {
  return ip_addr_list_.size();
}
inline int IMFileRsp::ip_addr_list_size() const {
  return _internal_ip_addr_list_size();
}
inline ::IM::BaseDefine::IpAddr* IMFileRsp::mutable_ip_addr_list(int index) {
  // @@protoc_insertion_point(field_mutable:IM.File.IMFileRsp.ip_addr_list)
  return ip_addr_list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IM::BaseDefine::IpAddr >*
IMFileRsp::mutable_ip_addr_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.File.IMFileRsp.ip_addr_list)
  return &ip_addr_list_;
}
inline const ::IM::BaseDefine::IpAddr& IMFileRsp::_internal_ip_addr_list(int index) const {
  return ip_addr_list_.Get(index);
}
inline const ::IM::BaseDefine::IpAddr& IMFileRsp::ip_addr_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileRsp.ip_addr_list)
  return _internal_ip_addr_list(index);
}
inline ::IM::BaseDefine::IpAddr* IMFileRsp::_internal_add_ip_addr_list() {
  return ip_addr_list_.Add();
}
inline ::IM::BaseDefine::IpAddr* IMFileRsp::add_ip_addr_list() {
  ::IM::BaseDefine::IpAddr* _add = _internal_add_ip_addr_list();
  // @@protoc_insertion_point(field_add:IM.File.IMFileRsp.ip_addr_list)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IM::BaseDefine::IpAddr >&
IMFileRsp::ip_addr_list() const {
  // @@protoc_insertion_point(field_list:IM.File.IMFileRsp.ip_addr_list)
  return ip_addr_list_;
}

// .IM.BaseDefine.TransferFileType trans_mode = 7;
inline void IMFileRsp::clear_trans_mode() {
  trans_mode_ = 0;
}
inline ::IM::BaseDefine::TransferFileType IMFileRsp::_internal_trans_mode() const {
  return static_cast< ::IM::BaseDefine::TransferFileType >(trans_mode_);
}
inline ::IM::BaseDefine::TransferFileType IMFileRsp::trans_mode() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileRsp.trans_mode)
  return _internal_trans_mode();
}
inline void IMFileRsp::_internal_set_trans_mode(::IM::BaseDefine::TransferFileType value) {
  
  trans_mode_ = value;
}
inline void IMFileRsp::set_trans_mode(::IM::BaseDefine::TransferFileType value) {
  _internal_set_trans_mode(value);
  // @@protoc_insertion_point(field_set:IM.File.IMFileRsp.trans_mode)
}

// -------------------------------------------------------------------

// IMFileNotify

// uint32 from_user_id = 1;
inline void IMFileNotify::clear_from_user_id() {
  from_user_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IMFileNotify::_internal_from_user_id() const {
  return from_user_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IMFileNotify::from_user_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileNotify.from_user_id)
  return _internal_from_user_id();
}
inline void IMFileNotify::_internal_set_from_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  from_user_id_ = value;
}
inline void IMFileNotify::set_from_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_from_user_id(value);
  // @@protoc_insertion_point(field_set:IM.File.IMFileNotify.from_user_id)
}

// uint32 to_user_id = 2;
inline void IMFileNotify::clear_to_user_id() {
  to_user_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IMFileNotify::_internal_to_user_id() const {
  return to_user_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IMFileNotify::to_user_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileNotify.to_user_id)
  return _internal_to_user_id();
}
inline void IMFileNotify::_internal_set_to_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  to_user_id_ = value;
}
inline void IMFileNotify::set_to_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_to_user_id(value);
  // @@protoc_insertion_point(field_set:IM.File.IMFileNotify.to_user_id)
}

// string file_name = 3;
inline void IMFileNotify::clear_file_name() {
  file_name_.ClearToEmpty();
}
inline const std::string& IMFileNotify::file_name() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileNotify.file_name)
  return _internal_file_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IMFileNotify::set_file_name(ArgT0&& arg0, ArgT... args) {
 
 file_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IM.File.IMFileNotify.file_name)
}
inline std::string* IMFileNotify::mutable_file_name() {
  std::string* _s = _internal_mutable_file_name();
  // @@protoc_insertion_point(field_mutable:IM.File.IMFileNotify.file_name)
  return _s;
}
inline const std::string& IMFileNotify::_internal_file_name() const {
  return file_name_.Get();
}
inline void IMFileNotify::_internal_set_file_name(const std::string& value) {
  
  file_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* IMFileNotify::_internal_mutable_file_name() {
  
  return file_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* IMFileNotify::release_file_name() {
  // @@protoc_insertion_point(field_release:IM.File.IMFileNotify.file_name)
  return file_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void IMFileNotify::set_allocated_file_name(std::string* file_name) {
  if (file_name != nullptr) {
    
  } else {
    
  }
  file_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:IM.File.IMFileNotify.file_name)
}

// uint32 file_size = 4;
inline void IMFileNotify::clear_file_size() {
  file_size_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IMFileNotify::_internal_file_size() const {
  return file_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IMFileNotify::file_size() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileNotify.file_size)
  return _internal_file_size();
}
inline void IMFileNotify::_internal_set_file_size(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  file_size_ = value;
}
inline void IMFileNotify::set_file_size(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_file_size(value);
  // @@protoc_insertion_point(field_set:IM.File.IMFileNotify.file_size)
}

// string task_id = 5;
inline void IMFileNotify::clear_task_id() {
  task_id_.ClearToEmpty();
}
inline const std::string& IMFileNotify::task_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileNotify.task_id)
  return _internal_task_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IMFileNotify::set_task_id(ArgT0&& arg0, ArgT... args) {
 
 task_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IM.File.IMFileNotify.task_id)
}
inline std::string* IMFileNotify::mutable_task_id() {
  std::string* _s = _internal_mutable_task_id();
  // @@protoc_insertion_point(field_mutable:IM.File.IMFileNotify.task_id)
  return _s;
}
inline const std::string& IMFileNotify::_internal_task_id() const {
  return task_id_.Get();
}
inline void IMFileNotify::_internal_set_task_id(const std::string& value) {
  
  task_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* IMFileNotify::_internal_mutable_task_id() {
  
  return task_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* IMFileNotify::release_task_id() {
  // @@protoc_insertion_point(field_release:IM.File.IMFileNotify.task_id)
  return task_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void IMFileNotify::set_allocated_task_id(std::string* task_id) {
  if (task_id != nullptr) {
    
  } else {
    
  }
  task_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), task_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:IM.File.IMFileNotify.task_id)
}

// repeated .IM.BaseDefine.IpAddr ip_addr_list = 6;
inline int IMFileNotify::_internal_ip_addr_list_size() const {
  return ip_addr_list_.size();
}
inline int IMFileNotify::ip_addr_list_size() const {
  return _internal_ip_addr_list_size();
}
inline ::IM::BaseDefine::IpAddr* IMFileNotify::mutable_ip_addr_list(int index) {
  // @@protoc_insertion_point(field_mutable:IM.File.IMFileNotify.ip_addr_list)
  return ip_addr_list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IM::BaseDefine::IpAddr >*
IMFileNotify::mutable_ip_addr_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.File.IMFileNotify.ip_addr_list)
  return &ip_addr_list_;
}
inline const ::IM::BaseDefine::IpAddr& IMFileNotify::_internal_ip_addr_list(int index) const {
  return ip_addr_list_.Get(index);
}
inline const ::IM::BaseDefine::IpAddr& IMFileNotify::ip_addr_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileNotify.ip_addr_list)
  return _internal_ip_addr_list(index);
}
inline ::IM::BaseDefine::IpAddr* IMFileNotify::_internal_add_ip_addr_list() {
  return ip_addr_list_.Add();
}
inline ::IM::BaseDefine::IpAddr* IMFileNotify::add_ip_addr_list() {
  ::IM::BaseDefine::IpAddr* _add = _internal_add_ip_addr_list();
  // @@protoc_insertion_point(field_add:IM.File.IMFileNotify.ip_addr_list)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IM::BaseDefine::IpAddr >&
IMFileNotify::ip_addr_list() const {
  // @@protoc_insertion_point(field_list:IM.File.IMFileNotify.ip_addr_list)
  return ip_addr_list_;
}

// .IM.BaseDefine.TransferFileType trans_mode = 7;
inline void IMFileNotify::clear_trans_mode() {
  trans_mode_ = 0;
}
inline ::IM::BaseDefine::TransferFileType IMFileNotify::_internal_trans_mode() const {
  return static_cast< ::IM::BaseDefine::TransferFileType >(trans_mode_);
}
inline ::IM::BaseDefine::TransferFileType IMFileNotify::trans_mode() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileNotify.trans_mode)
  return _internal_trans_mode();
}
inline void IMFileNotify::_internal_set_trans_mode(::IM::BaseDefine::TransferFileType value) {
  
  trans_mode_ = value;
}
inline void IMFileNotify::set_trans_mode(::IM::BaseDefine::TransferFileType value) {
  _internal_set_trans_mode(value);
  // @@protoc_insertion_point(field_set:IM.File.IMFileNotify.trans_mode)
}

// uint32 offline_ready = 8;
inline void IMFileNotify::clear_offline_ready() {
  offline_ready_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IMFileNotify::_internal_offline_ready() const {
  return offline_ready_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IMFileNotify::offline_ready() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileNotify.offline_ready)
  return _internal_offline_ready();
}
inline void IMFileNotify::_internal_set_offline_ready(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  offline_ready_ = value;
}
inline void IMFileNotify::set_offline_ready(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_offline_ready(value);
  // @@protoc_insertion_point(field_set:IM.File.IMFileNotify.offline_ready)
}

// -------------------------------------------------------------------

// IMFileHasOfflineReq

// uint32 user_id = 1;
inline void IMFileHasOfflineReq::clear_user_id() {
  user_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IMFileHasOfflineReq::_internal_user_id() const {
  return user_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IMFileHasOfflineReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileHasOfflineReq.user_id)
  return _internal_user_id();
}
inline void IMFileHasOfflineReq::_internal_set_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  user_id_ = value;
}
inline void IMFileHasOfflineReq::set_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:IM.File.IMFileHasOfflineReq.user_id)
}

// bytes attach_data = 20;
inline void IMFileHasOfflineReq::clear_attach_data() {
  attach_data_.ClearToEmpty();
}
inline const std::string& IMFileHasOfflineReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileHasOfflineReq.attach_data)
  return _internal_attach_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IMFileHasOfflineReq::set_attach_data(ArgT0&& arg0, ArgT... args) {
 
 attach_data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IM.File.IMFileHasOfflineReq.attach_data)
}
inline std::string* IMFileHasOfflineReq::mutable_attach_data() {
  std::string* _s = _internal_mutable_attach_data();
  // @@protoc_insertion_point(field_mutable:IM.File.IMFileHasOfflineReq.attach_data)
  return _s;
}
inline const std::string& IMFileHasOfflineReq::_internal_attach_data() const {
  return attach_data_.Get();
}
inline void IMFileHasOfflineReq::_internal_set_attach_data(const std::string& value) {
  
  attach_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* IMFileHasOfflineReq::_internal_mutable_attach_data() {
  
  return attach_data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* IMFileHasOfflineReq::release_attach_data() {
  // @@protoc_insertion_point(field_release:IM.File.IMFileHasOfflineReq.attach_data)
  return attach_data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void IMFileHasOfflineReq::set_allocated_attach_data(std::string* attach_data) {
  if (attach_data != nullptr) {
    
  } else {
    
  }
  attach_data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), attach_data,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:IM.File.IMFileHasOfflineReq.attach_data)
}

// -------------------------------------------------------------------

// IMFileHasOfflineRsp

// uint32 user_id = 1;
inline void IMFileHasOfflineRsp::clear_user_id() {
  user_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IMFileHasOfflineRsp::_internal_user_id() const {
  return user_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IMFileHasOfflineRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileHasOfflineRsp.user_id)
  return _internal_user_id();
}
inline void IMFileHasOfflineRsp::_internal_set_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  user_id_ = value;
}
inline void IMFileHasOfflineRsp::set_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:IM.File.IMFileHasOfflineRsp.user_id)
}

// repeated .IM.BaseDefine.OfflineFileInfo offline_file_list = 2;
inline int IMFileHasOfflineRsp::_internal_offline_file_list_size() const {
  return offline_file_list_.size();
}
inline int IMFileHasOfflineRsp::offline_file_list_size() const {
  return _internal_offline_file_list_size();
}
inline ::IM::BaseDefine::OfflineFileInfo* IMFileHasOfflineRsp::mutable_offline_file_list(int index) {
  // @@protoc_insertion_point(field_mutable:IM.File.IMFileHasOfflineRsp.offline_file_list)
  return offline_file_list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IM::BaseDefine::OfflineFileInfo >*
IMFileHasOfflineRsp::mutable_offline_file_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.File.IMFileHasOfflineRsp.offline_file_list)
  return &offline_file_list_;
}
inline const ::IM::BaseDefine::OfflineFileInfo& IMFileHasOfflineRsp::_internal_offline_file_list(int index) const {
  return offline_file_list_.Get(index);
}
inline const ::IM::BaseDefine::OfflineFileInfo& IMFileHasOfflineRsp::offline_file_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileHasOfflineRsp.offline_file_list)
  return _internal_offline_file_list(index);
}
inline ::IM::BaseDefine::OfflineFileInfo* IMFileHasOfflineRsp::_internal_add_offline_file_list() {
  return offline_file_list_.Add();
}
inline ::IM::BaseDefine::OfflineFileInfo* IMFileHasOfflineRsp::add_offline_file_list() {
  ::IM::BaseDefine::OfflineFileInfo* _add = _internal_add_offline_file_list();
  // @@protoc_insertion_point(field_add:IM.File.IMFileHasOfflineRsp.offline_file_list)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IM::BaseDefine::OfflineFileInfo >&
IMFileHasOfflineRsp::offline_file_list() const {
  // @@protoc_insertion_point(field_list:IM.File.IMFileHasOfflineRsp.offline_file_list)
  return offline_file_list_;
}

// repeated .IM.BaseDefine.IpAddr ip_addr_list = 3;
inline int IMFileHasOfflineRsp::_internal_ip_addr_list_size() const {
  return ip_addr_list_.size();
}
inline int IMFileHasOfflineRsp::ip_addr_list_size() const {
  return _internal_ip_addr_list_size();
}
inline ::IM::BaseDefine::IpAddr* IMFileHasOfflineRsp::mutable_ip_addr_list(int index) {
  // @@protoc_insertion_point(field_mutable:IM.File.IMFileHasOfflineRsp.ip_addr_list)
  return ip_addr_list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IM::BaseDefine::IpAddr >*
IMFileHasOfflineRsp::mutable_ip_addr_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.File.IMFileHasOfflineRsp.ip_addr_list)
  return &ip_addr_list_;
}
inline const ::IM::BaseDefine::IpAddr& IMFileHasOfflineRsp::_internal_ip_addr_list(int index) const {
  return ip_addr_list_.Get(index);
}
inline const ::IM::BaseDefine::IpAddr& IMFileHasOfflineRsp::ip_addr_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileHasOfflineRsp.ip_addr_list)
  return _internal_ip_addr_list(index);
}
inline ::IM::BaseDefine::IpAddr* IMFileHasOfflineRsp::_internal_add_ip_addr_list() {
  return ip_addr_list_.Add();
}
inline ::IM::BaseDefine::IpAddr* IMFileHasOfflineRsp::add_ip_addr_list() {
  ::IM::BaseDefine::IpAddr* _add = _internal_add_ip_addr_list();
  // @@protoc_insertion_point(field_add:IM.File.IMFileHasOfflineRsp.ip_addr_list)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IM::BaseDefine::IpAddr >&
IMFileHasOfflineRsp::ip_addr_list() const {
  // @@protoc_insertion_point(field_list:IM.File.IMFileHasOfflineRsp.ip_addr_list)
  return ip_addr_list_;
}

// bytes attach_data = 20;
inline void IMFileHasOfflineRsp::clear_attach_data() {
  attach_data_.ClearToEmpty();
}
inline const std::string& IMFileHasOfflineRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileHasOfflineRsp.attach_data)
  return _internal_attach_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IMFileHasOfflineRsp::set_attach_data(ArgT0&& arg0, ArgT... args) {
 
 attach_data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IM.File.IMFileHasOfflineRsp.attach_data)
}
inline std::string* IMFileHasOfflineRsp::mutable_attach_data() {
  std::string* _s = _internal_mutable_attach_data();
  // @@protoc_insertion_point(field_mutable:IM.File.IMFileHasOfflineRsp.attach_data)
  return _s;
}
inline const std::string& IMFileHasOfflineRsp::_internal_attach_data() const {
  return attach_data_.Get();
}
inline void IMFileHasOfflineRsp::_internal_set_attach_data(const std::string& value) {
  
  attach_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* IMFileHasOfflineRsp::_internal_mutable_attach_data() {
  
  return attach_data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* IMFileHasOfflineRsp::release_attach_data() {
  // @@protoc_insertion_point(field_release:IM.File.IMFileHasOfflineRsp.attach_data)
  return attach_data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void IMFileHasOfflineRsp::set_allocated_attach_data(std::string* attach_data) {
  if (attach_data != nullptr) {
    
  } else {
    
  }
  attach_data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), attach_data,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:IM.File.IMFileHasOfflineRsp.attach_data)
}

// -------------------------------------------------------------------

// IMFileAddOfflineReq

// uint32 from_user_id = 1;
inline void IMFileAddOfflineReq::clear_from_user_id() {
  from_user_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IMFileAddOfflineReq::_internal_from_user_id() const {
  return from_user_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IMFileAddOfflineReq::from_user_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileAddOfflineReq.from_user_id)
  return _internal_from_user_id();
}
inline void IMFileAddOfflineReq::_internal_set_from_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  from_user_id_ = value;
}
inline void IMFileAddOfflineReq::set_from_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_from_user_id(value);
  // @@protoc_insertion_point(field_set:IM.File.IMFileAddOfflineReq.from_user_id)
}

// uint32 to_user_id = 2;
inline void IMFileAddOfflineReq::clear_to_user_id() {
  to_user_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IMFileAddOfflineReq::_internal_to_user_id() const {
  return to_user_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IMFileAddOfflineReq::to_user_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileAddOfflineReq.to_user_id)
  return _internal_to_user_id();
}
inline void IMFileAddOfflineReq::_internal_set_to_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  to_user_id_ = value;
}
inline void IMFileAddOfflineReq::set_to_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_to_user_id(value);
  // @@protoc_insertion_point(field_set:IM.File.IMFileAddOfflineReq.to_user_id)
}

// string task_id = 3;
inline void IMFileAddOfflineReq::clear_task_id() {
  task_id_.ClearToEmpty();
}
inline const std::string& IMFileAddOfflineReq::task_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileAddOfflineReq.task_id)
  return _internal_task_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IMFileAddOfflineReq::set_task_id(ArgT0&& arg0, ArgT... args) {
 
 task_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IM.File.IMFileAddOfflineReq.task_id)
}
inline std::string* IMFileAddOfflineReq::mutable_task_id() {
  std::string* _s = _internal_mutable_task_id();
  // @@protoc_insertion_point(field_mutable:IM.File.IMFileAddOfflineReq.task_id)
  return _s;
}
inline const std::string& IMFileAddOfflineReq::_internal_task_id() const {
  return task_id_.Get();
}
inline void IMFileAddOfflineReq::_internal_set_task_id(const std::string& value) {
  
  task_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* IMFileAddOfflineReq::_internal_mutable_task_id() {
  
  return task_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* IMFileAddOfflineReq::release_task_id() {
  // @@protoc_insertion_point(field_release:IM.File.IMFileAddOfflineReq.task_id)
  return task_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void IMFileAddOfflineReq::set_allocated_task_id(std::string* task_id) {
  if (task_id != nullptr) {
    
  } else {
    
  }
  task_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), task_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:IM.File.IMFileAddOfflineReq.task_id)
}

// string file_name = 4;
inline void IMFileAddOfflineReq::clear_file_name() {
  file_name_.ClearToEmpty();
}
inline const std::string& IMFileAddOfflineReq::file_name() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileAddOfflineReq.file_name)
  return _internal_file_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IMFileAddOfflineReq::set_file_name(ArgT0&& arg0, ArgT... args) {
 
 file_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IM.File.IMFileAddOfflineReq.file_name)
}
inline std::string* IMFileAddOfflineReq::mutable_file_name() {
  std::string* _s = _internal_mutable_file_name();
  // @@protoc_insertion_point(field_mutable:IM.File.IMFileAddOfflineReq.file_name)
  return _s;
}
inline const std::string& IMFileAddOfflineReq::_internal_file_name() const {
  return file_name_.Get();
}
inline void IMFileAddOfflineReq::_internal_set_file_name(const std::string& value) {
  
  file_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* IMFileAddOfflineReq::_internal_mutable_file_name() {
  
  return file_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* IMFileAddOfflineReq::release_file_name() {
  // @@protoc_insertion_point(field_release:IM.File.IMFileAddOfflineReq.file_name)
  return file_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void IMFileAddOfflineReq::set_allocated_file_name(std::string* file_name) {
  if (file_name != nullptr) {
    
  } else {
    
  }
  file_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:IM.File.IMFileAddOfflineReq.file_name)
}

// uint32 file_size = 5;
inline void IMFileAddOfflineReq::clear_file_size() {
  file_size_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IMFileAddOfflineReq::_internal_file_size() const {
  return file_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IMFileAddOfflineReq::file_size() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileAddOfflineReq.file_size)
  return _internal_file_size();
}
inline void IMFileAddOfflineReq::_internal_set_file_size(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  file_size_ = value;
}
inline void IMFileAddOfflineReq::set_file_size(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_file_size(value);
  // @@protoc_insertion_point(field_set:IM.File.IMFileAddOfflineReq.file_size)
}

// -------------------------------------------------------------------

// IMFileDelOfflineReq

// uint32 from_user_id = 1;
inline void IMFileDelOfflineReq::clear_from_user_id() {
  from_user_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IMFileDelOfflineReq::_internal_from_user_id() const {
  return from_user_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IMFileDelOfflineReq::from_user_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileDelOfflineReq.from_user_id)
  return _internal_from_user_id();
}
inline void IMFileDelOfflineReq::_internal_set_from_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  from_user_id_ = value;
}
inline void IMFileDelOfflineReq::set_from_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_from_user_id(value);
  // @@protoc_insertion_point(field_set:IM.File.IMFileDelOfflineReq.from_user_id)
}

// uint32 to_user_id = 2;
inline void IMFileDelOfflineReq::clear_to_user_id() {
  to_user_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IMFileDelOfflineReq::_internal_to_user_id() const {
  return to_user_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IMFileDelOfflineReq::to_user_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileDelOfflineReq.to_user_id)
  return _internal_to_user_id();
}
inline void IMFileDelOfflineReq::_internal_set_to_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  to_user_id_ = value;
}
inline void IMFileDelOfflineReq::set_to_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_to_user_id(value);
  // @@protoc_insertion_point(field_set:IM.File.IMFileDelOfflineReq.to_user_id)
}

// string task_id = 3;
inline void IMFileDelOfflineReq::clear_task_id() {
  task_id_.ClearToEmpty();
}
inline const std::string& IMFileDelOfflineReq::task_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileDelOfflineReq.task_id)
  return _internal_task_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IMFileDelOfflineReq::set_task_id(ArgT0&& arg0, ArgT... args) {
 
 task_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IM.File.IMFileDelOfflineReq.task_id)
}
inline std::string* IMFileDelOfflineReq::mutable_task_id() {
  std::string* _s = _internal_mutable_task_id();
  // @@protoc_insertion_point(field_mutable:IM.File.IMFileDelOfflineReq.task_id)
  return _s;
}
inline const std::string& IMFileDelOfflineReq::_internal_task_id() const {
  return task_id_.Get();
}
inline void IMFileDelOfflineReq::_internal_set_task_id(const std::string& value) {
  
  task_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* IMFileDelOfflineReq::_internal_mutable_task_id() {
  
  return task_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* IMFileDelOfflineReq::release_task_id() {
  // @@protoc_insertion_point(field_release:IM.File.IMFileDelOfflineReq.task_id)
  return task_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void IMFileDelOfflineReq::set_allocated_task_id(std::string* task_id) {
  if (task_id != nullptr) {
    
  } else {
    
  }
  task_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), task_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:IM.File.IMFileDelOfflineReq.task_id)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace File
}  // namespace IM

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_IM_2eFile_2eproto
